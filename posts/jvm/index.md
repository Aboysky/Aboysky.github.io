# JVM


# JVM

## 基于栈的指令集架构和基于寄存器的指令集架构

### 栈

- 同样操作指令更多，因为有许多入栈出栈操作指令，但是指令一般不带参数。并且由于栈在内存中，肯定比不上寄存器的访问速度。

## 空间分布

### 线程公有

- 堆
- 方法区

	- 在HotSpot虚拟机上，1.7之前一般就默认称为永久代，因为HotSpot虚拟机将这块内存一起纳入了垃圾回收机制的范围，但是由于JVM内存有总量限制，所以在1.7开始就逐渐把原本属于永久代的东西移到本地内存，但是1.7中常量池，静态变量等还是在方法区，1.8后移入堆中，永久代彻底消失。
	- 运行时常量池

		- 主要用来存放编译期生成的各种字面量和符号引用。但是也可以存放在运行期添加进入的，由于他在方法区，所以仍然可能产生OOM。

### 线程私有

- 程序计数器
- 虚拟机栈

	- 每个方法被执行的时候，都会自动创建一个栈帧，其中包括局部变量表，操作数栈，动态连接，方法出口等等。
	- 局部变量表

		- 局部变量槽Slot

			- long
			- double占两个

	- 异常

		- StackOverFlowError 

			- 申请栈帧的数量超过虚拟机允许的最大深度

		- OutOfMemoryError

			- 总栈帧占的地址空间大于最大的栈空间，由于HotSpot虚拟机不支持栈容量动态扩展，所以发生OOM只可能在新建线程给线程分配堆缓冲池时TLAB。

	- -Xss

- 本地方法栈

	- 异常

		- StackOverFlowError 

			- 申请栈帧的数量超过虚拟机允许的最大深度

		- OutOfMemoryError

			- 总栈帧占的地址空间大于最大的栈空间

### 直接内存

- DirectByteBuffer 
- 由于主机内存有限制，所以也可能产生OOM

## 垃圾回收

### 哪些对象需要回收？已经“死”去的对象

- 引用计数法（可能造成循环引用）
- 可达性分析

	- GC Roots

		- 虚拟机栈中引用的对象
		- 方法区中类静态属性的引用
		- 方法区中常量引用
		- synchronized持有的对象
		- 临时的对象

- 引用

	- 四种引用类型

		- 强引用

			- new 出来的都是强引用，如果一个对象被强引用引用，当内存不够时，jvm宁愿爆出oom，也不愿意将拥有强引用引用的对象回收。

		- 软引用 （SoftReference）

			- 软引用是引用强度上仅次于强引用的，他的类是public，只有强引用的类是仅包内可见的。软引用的对象在jvm内存资源充足的时候不会被回收，但是内存资源紧张的时候会被回收。一般可以用来作为缓存区的引用。

		- 弱引用（WeakReference）

			- 弱引用是最弱的一种可以直接取到链接对象值的一个引用，在gc时，jvm碰到弱引用则直接回收。有一个用在内存敏感的WeakHashMap就是用的WeakReference，它通过监控ReferenceQueue来完成Entry的清洗。

		- 虚引用/幽灵引用（PhantomReference）

			- 最弱的引用，不能直接访问到对象，一般可以用来通知某个对象是否被回收。他有一个子类，Cleaner，用来负责对DirectByteBuffer的回收，创建DirectByteBuffer对象时会创建一个Cleaner对象，Cleaner对象持有了DirectByteBuffer对象的引用。当JVM在GC时，如果发现DirectByteBuffer被地方法没被引用啦，JVM会将其对应的Cleaner加入到pending-reference链表中，同时通知ReferenceHandler线程处理，ReferenceHandler收到通知后，会调用Cleaner#clean方法，而对于DirectByteBuffer创建的Cleaner对象其clean方法内部会调用unsafe.freeMemory释放堆外内存。最终达到了DirectByteBuffer对象被GC回收其对应的堆外内存也被回收的目的。

- 类卸载

	- 1. 该类没有任何实例
	- 2. 加载该类的类加载器已经被回收
	- 3. Class类没有在任何地方被引用

- 可达性分析之后如果被标记为不可达，此时将对对象进行第一次标记，然后判断对象是否有必要执行finalize方法，如果有必要，则将其加入F-Queue队列，这个队列将由一个jvm自动建立的低优先级的线程去执行他们的finalize方法，这里说的执行是虚拟机会保证他执行，但是不保证他执行完，因为有可能这里执行缓慢或者死循环。然后将会对这里的对象进行第二次小规模的标记，如果有可以被连接上的，则将其移除这个即将被回收的集合

### 垃圾收集算法

- 分代收集理论

	- 弱分代假说

		- 大部分对象都是朝生夕灭

	- 强分代假说

		- 熬过越多次垃圾回收就越难消亡

	- 跨代引用假说

		- 跨代引用相对于同代引用来说终究是少数
		- 记忆集

			- 新生代上建立一个数据结构，将老年代分为一块一块的，他指明老年代的哪些块有跨代引用。这个需要每次改变引用时都维护这个数据集的正确性，但是相比于gc时扫描全部老年代来说划算的多

- 垃圾回收算法

	- 标记清除算法

	  标记存活的或者死亡的，然后清除。
	  缺点： 执行效率不稳定，内存空间的碎片化
	
- 标记-复制算法
	
  将空间分为两块或以上，标记存活的对象，然后将存活的对象整体移动到另外一块内存上，这样分配内存的时候就只需要移动指针就可以了。
	  HotSpot的Serial，ParNew等新生代回收器都采用了这种。他们的内存划分为三块，一块较大的Eden（80%），两块小的survivor（10%一块），每次只使用一块Eden和一块survivor。
	  分配担保: 
	         假如10%的区域不够，则分配到老年代，由老年代进行分配担保。
	
	- 标记-整理算法

	  标记存活的，然后将其移动到一起。防止内存碎片化。
  因为需要移动对象，所以相对来说垃圾回收会比较复杂，但是如果移动，那么对象的分配就会更加复杂。相比来说，如果更加关注吞吐量，那么就选择移动，因为HotSpot中关注吞吐量的Parallel Scavenge是选择标记整理算法的。但是关注延迟的CMS是标记-清除算法的。但是CMS的策略是暂时容忍内存碎片，等到它已经影响到分配对象时，则再用标记-整理算法清理一遍。
	  
	  
	
- HosSpot垃圾回收算法实现

	- 根节点枚举

		- 因为根节点枚举需要系统中准确的全部的引用，所以这一个地方需要暂停所有的用户线程。‘
		- 准确式内存管理： 明确知道栈中或者某地方的变量中到底是值还是引用。
		- OopMap

			- 准确的记录了哪些地方存放着对象引用

		- 安全点

			- 因为导致OopMap变化的指令非常多，jvm不可能在每一个指令都去更改OopMap，这样就出现了安全点，在这块区域，指令的更改将会导致OopMap的更新。因此安全点选取的标准就是是否具有让程序长时间执行的特征。

		- 如果让所有的线程跑到安全点上停止下来？

			- 抢先式中断

				- 先把所有用户程序暂停，如果发现某个线程不在安全点，则让他再运行一会，然后中断，直到它在安全点，但是基本上没有jvm采用这种方法

			- 主动式中断

				- 轮询标志位，标志位一般和安全点在一个地方，再加上需要分配堆空间的地方。当标志位为真时，则到最近的一个安全点主动中断挂起。因为轮询非常普遍，所以要求足够精简。一般是通过test指令来测试访问标志位，如果不能访问成功，则产生一个自陷异常信号，然后交给预先注册的异常处理器中处理。

		- 安全区域

			- 当一些线程在阻塞或是sleep的时候，线程不能走到最近的安全点，但jvm也不可能等到阻塞的线程直到执行才开始回收。所以就有了安全区域，当线程进入安全区域时，他会标志自己进入了安全区域，安全区域就是这段代码不会影响到引用的改变。当阻塞或者sleep的线程想要从安全区域出来继续运行的时候，需要先判断类如根节点枚举或者其他需要暂停用户线程的这些阶段是否完成，如果完成了，才能继续执行，否则继续在安全区域等待。直到收到可以离开安全区域的信号为止

		- 记忆集

		  卡表的更新问题，因为每次引用的改变都必须去判断是否需要更新卡表，而这个如果是解释器去执行，那么中间可能有很多机会可以去更新卡表。但是jvm中有许多是编译的代码，是机器指令流的方式，那么也就必须将更新的这个操作一起集合在赋值的时候，这就是写屏障，写屏障类似于环绕型AOP切片，可以在赋值的后面插入更新卡表的命令。但是这里也有一个伪共享的问题，那就是因为cpu的缓存是缓存行，假设一行是64个字节，而卡表一般最简单就是字节数组，那么也就是一个缓存行里面可以放入64个卡页，也就是对应32KB的空间，如果多个线程同时对这32KB中的对象进行修改，那么由于缓存行的问题，就可能造成修改无效或者失败或者性能问题。解决方法就是在修改前加一个判断，判断这个卡页是否已经变脏，如果没有变脏，才将他变脏。控制参数为：-XX:+UseCondCardMark
		  

			- 为了解决局部回收时跨代引用的问题，引入了记忆集的抽象数据结构，他一般有三种精度，字长精度，对象精度，和卡精度。最常用的就是卡精度，因为没有必要花费这么多的时间和空间去记忆的这么精准。HotSpot虚拟机中每卡页为512个字节，当这个卡页中有对象存在跨代引用，则将这个卡页标志为1
			- 写屏障

			  卡表的更新问题，因为每次引用的改变都必须去判断是否需要更新卡表，而这个如果是解释器去执行，那么中间可能有很多机会可以去更新卡表。但是jvm中有许多是编译的代码，是机器指令流的方式，那么也就必须将更新的这个操作一起集合在赋值的时候，这就是写屏障，写屏障类似于环绕型AOP切片，可以在赋值的后面插入更新卡表的命令。但是这里也有一个伪共享的问题，那就是因为cpu的缓存是缓存行，假设一行是64个字节，而卡表一般最简单就是字节数组，那么也就是一个缓存行里面可以放入64个卡页，也就是对应32KB的空间，如果多个线程同时对这32KB中的对象进行修改，那么由于缓存行的问题，就可能造成修改无效或者失败或者性能问题。解决方法就是在修改前加一个判断，判断这个卡页是否已经变脏，如果没有变脏，才将他变脏。控制参数为：-XX:+UseCondCardMark
			  

	- 并发的可达性分析

		- 目的：当gcroot扫描线程和用户线程并发执行时，不会由于用户线程对引用的更改导致将原本是存活的对象误删除
		- 三色标记

			- 黑色: 存活，不会再扫描
			- 灰色： 扫描过，但是至少还有一个引用没有扫描
			- 白色： 还没有被扫描到的

		- 导致黑色对象变成白色必须满足的两个条件

			- 1. 黑色对象新增了一条或者多条对白色对象的引用
			- 2. 所有的灰色对象删除对该白色对象的直接或者间接引用。

		- 处理方法

			- 增量更新

				- 在黑色对象增加对白色对象的引用时，将其记录起来，等到扫描完后再单独对记录的这个黑色节点再次扫描，破坏的是第一个条件，CMS在用

			- 原始快照

				- 在删除灰色节点到白色节点的引用时，就把这个要删除的引用记录下来，在并发扫描结束后，再将这些重新扫描一次。可以这样理解，无论引用关系是否删除，都按照最开始的原始快照那样再扫描一次这些记录的节点。

			- 比较

				- CMS使用了增量跟新，但是G1采用的是原始快照也就是TLAB，TLAB需要采用写前屏障来跟踪并发时的指针变化情况。但是原始快照可以节省并发标记和重新标记阶段的消耗。

### 经典垃圾回收器

- 
- Serial （新生代收集器）

	- 1. 单线程 

		- 1. 垃圾回收只有一个线程
		- 2. 垃圾回收中暂停所有其他线程。

	- 新生代

		- 复制算法

	- 老年代

		- 标记-整理算法

	- 使用场景

		- 资源受限的环境，因为他的额外内存消耗最小

- ParNew

	- 除了可以多线程并行收集之外，其他的一切都和Serial一样，照样要暂停所有其他线程，回收策略等等都一样。新生代收集器
	- 但是在服务器端它用的相对很多，主要是它可以与CMS配合使用。在JDK9及以后，只能和CMS配合使用。也就是选择CMS之后的新生代收集就默认使用的它。

- Parallel Scavenge（新生代收集器）

	- 多线程并行收集，标记复制算法
	- 目标

		- 达到一个可控制的吞吐量，而CMS等关注的是尽量缩短垃圾收集时用户线程的停顿时间
		- 吞吐量 = 运行用户代码时间  / 运行用户代码时间 + 运行垃圾收集时间

	- 控制参数

		- -XX:MaxGCPauseMilis 控制最大垃圾收集停顿时间

			- 毫秒数，但是设置的越低，是去缩减新生代的大小来达到的，增加了收集次数，但是减少了时间

		- -XX:GCTimeRatio 设置吞吐量

			- 可以设置一个0-100内的整数，比如19，那么系统则保证垃圾回收时间小于1/(1 + 19) 等于5%以内。默认是99，也就是保证小于1%；

		- -XX:+UseAdativeSizePolicy

			- jvm根据系统状态去调节时间和吞吐量参数，但是你可以给他一个目标，比如你设置最大停顿时间为100ms，它则会往这个方向去优化

- Serial Old （老年代回收）

	- 单线程，标记整理
	- 使用场景：

		- jdk5之前配合Parallel Scavenge 使用
		- CMS收集器失败之后的后备预案

- Parallel Old（老年代回收）

	- 是Parallel Scavenge的老年代版本
	- 多线程并发收集，标记-整理算法，JDK6开始提供
	- 使用场景：

		- 配合Parallel Scavenge使用，在一些注重吞吐量的系统中使用

- CMS (Concurrent Mark Sweep)收集器（老年代回收）

	- 目标

		- 获取最短停顿时间

	- 标记清除算法
	- 运行过程

		- 初始标记

			- 标记那些GC roots直接引用的对象，JDK7及以前是单线程，jdk8以后改为多线程

		- 并发标记

			- 从初始标记的开始扫描所有的对象图

		- 重新标记

			- 增量更新，主要为了避免删除那些存活的但是被标记为白色的对象。

		- 并发清理

	- 缺点

		- 1. 对处理器资源非常敏感，不适合在一些处理器内核数量较小的平台上使用。
		- 2. CMS无法处理浮动垃圾。因为并发时用户线程在执行，肯定会产生很多垃圾，但是这些垃圾不在原本的对象图中，所有无法被收集。这样导致CMS必须留出空间给并发收集时新对象的分配空间用。如果新对象分配时申请不到空间，则将导致CMS并发收集失败，导致需要掉用备用的Serial Old来进行垃圾回收，但是这样就要暂停掉所有用户线程。
		- 3. 由于CMS采用的是标记清除算法，所以肯定会导致很多的垃圾碎片，这样就肯定会导致FULL GC提前触发。

- G1(Garbage First)全功能垃圾回收器

	- 1. 它并不将堆按照原本的新生代，老年代这样的来划分内存结构，而是将整个堆划分为一个个的region，每个region都可以按照需求变为新生代或者老年代。
	- 2. 有一类特殊的region，humongous，专门用来存放大对象，避免复制，直接进入老年代，大对象的判断是是否大于region的1/2，
	- 3. SATB 原始快照，采用原始快照来解决并发标记时可能将存活的对象清理。
	- 4. Rset 记忆集，和卡表有点像，但是不一致，卡表采用的是points-out（我引用了谁），G1的记忆集用的是points-in(谁引用了我的对象)。
	- 5. 停顿预测模型

		- 通过前面的垃圾回收的时间收集，以衰减均值作为理论模型，也就是新数据所占权重比旧数据高。

	- 执行过程

		- 1. 初始标记

			- 暂停用户进程

		- 2. 并发标记
		- 3. 最终标记

			- 重新标记TLAB剩余的引用

		- 4. 清除垃圾

			- 把决定回收的region里面所有存活的对向复制到另一个空region中去，然后清除掉这个旧region的全部内容

- shenandoah

	- G1的升级版，最重要的是支持了并发的整理算法，以及低延迟，他们的项目目标是做到10ms一下
	- 去掉了G1中非常占用资源的Rset，改为连接矩阵来进行标记跨区引用
	- 过程

		- 1. 初始标记

			- stop the world

		- 2. 并发标记
		- 3. 最终标记
		- 4. 并发清理

			- 清理那些一个存活对象都没有的region

		- 5. 并发回收

			- 将存活的对象复制一份到其他region，是和G1的核心差别，主要技术有读屏障和Brooks Pointers转发指针

		- 6. 初始引用更新

			- 主要是等待前一步的所有并发线程都工作完毕

		- 7. 并发引用更新

			- 真正的进行引用更新操作。按照地址空间的顺序来进行

		- 8. 最终引用更新

			- 修正存在于GC roots中的引用。需要暂停所有用户进程

		- 9. 并发清理

			- 清理掉回收集中的所有region

	- 对象移动和用户程序的并发

		- 保护陷进

			- 效率低，频繁的状态转换

		- brooks Pointers

		  brooks pointers 是通过在原本的对象结构的基础上，在他的前面添加一个新的引用，当这个对象不在并发移动时，值为它自己。但是在并发移动时，值为它的新的地址。
		  这样带来一个性能消耗，就是每次访问对象都需要访问两次。但是相比于保护陷阱带来的状态切换，还是可以接受。
		  但是这样带来了一个多线程访问时的问题，当jvm在移动对象时，如果这个时候有一个写入进程来修改此对象，但是假如此时jvm并没有来的及修改转发指针的地址，导致他将新的修改修改在了旧的对象上，这是绝对不允许发生的，jvm采用了cas来保证并发时对象的访问正确性的。
		  

	- 读写屏障

		- 基于引用的访问屏障

- ZGC收集器

	- 基于Region，不设分代，使用了读屏障，染色指针，和内存多重映射等来实现可并发的标记-整理算法的，以低延迟为目标的
	- 染色指针
	- 多重映射

## 垃圾回收算法

### 标记清除算法

### 标记整理算法

## 内存分配和回收

### 1. 对象优先在Eden分配

### 2. 大对象直接进入老年代

### 3. 长期存活（年龄大于等于15）则进入老年代

### 4. 动态对象年龄判断（只要Suivivor中同年龄的对象超过Survivor空间的一半，则大于等于此年龄的全部进入老年代）

### 5. 空间分配担保

- 在发送Minor gc前需要判断老年代是否有连续的大于新生代所有对象的总空间或者历次进入到老年代的平均大小，如果有，则进行一次Minor gc，如果最后发现老年代空间不够，则触发一次Full gc。

## OOM异常分析和排除

### 堆OOM

- -Xms -Xmx  -XX:+HeapDumpOnOutOfMemoryError   出现异常时Dump出内存堆转储快照

## 面试问题

### new 一个对象的过程

1. 先去常量池，查找这个类的符号引号，判断这个类是否被加载进jvm。
2. 如果类已经加载进jvm，则继续下一步操作，如果没有，加载进jvm
3. 因为新建对象的类信息已经加载进jvm，所以此类的对象所需要占有的大小是确定的，在堆中分配一块此大小的地址给此对象。
4. 因为不同垃圾回收器可能不一定有空间压缩操作，所以分配地址就有可能有两种情况，第一种是简单的移动一下指针，因为此时的空间是被压缩过的。另一种就是比较复杂的空闲链表，在其中找到一块比这个大的切割后分配给他，将剩余的继续加入空闲链表。
5. 因为new 对象在jvm中是非常常见的事，所以指针移动需要进行线程安全保证。虚拟机一般上是使用CAS配上失败重试来保证更新操作的原子性。另外一种保证线程安全的就是通过TLAB（本地线程分配缓冲），当jvm中创建一个线程时，就在堆中提前给他分配一块地址，此线程就在此空间内进行对象内存分配。只有此空间用完了，重新分配时才需要保证线程安全。
6. 空间分配后，应该将该空间里面进行全部的初始化（不包括对象头），以保证类属性可以被初始化，当然这一步操作可以在TLAB分配时就顺便进行。
7. jvm对对象头进行一定的设置，比如这个对象的是什么类的实例，如果才能找到元数据，对象的gc分类等等。
8. 上面步骤完成后，类的创建就基本上完成了，但是还有一步很重要的操作没有进行，那就是构造函数还没有执行。一般new出来的对象在new指令后面都有一个invokespecial指令，这个指令指向对象的构造方法。


###         String str1 = new StringBuilder("计算机").append("软件").toString();
        String str2 = new StringBuilder("ja").append("va").toString();
        System.out.println(str1.intern() == str1);
        System.out.println(str2.intern() == str2);

- true,false从jdk7开始字符串常量池移动到了堆中，因为这些StringBuilder创建对象也在堆中，所以这个时候就进行了更改，Intern方法时，直接就将堆中的这个对象的地址记录了下来，也就是常量池中指向的就是这个地址。

## - : 标准VM选项，VM规范的选项
-X: 非标准VM选项，不保证所有VM支持
-XX: 高级选项，高级特性，但属于不稳定的选项


## 虚拟机的类加载机制

### 加载过程

- 加载

	- 通过类的全限定名拿到类的二进制字节流，并且将二进制字节流转化为方法区的运行时数据结构，并且在堆中生成一个此类的Class对象

- 连接

	- 验证

		- 文件格式验证
		- 元数据验证

			- 语义分析代码，符合java的规范

		- 字节码验证
		- 符号引用验证

	- 准备

		- 为类属性分配内存并且初始化为00000.final修饰的常量此时会被赋值。

	- 解析

		- 把符号引用转化为直接引用

- 初始化

	- 执行clinit方法，类变量的赋值语句和静态语句块中的语句，多线程时必须保证只有一个线程去执行这个操作。

### 类加载器

- 启动类加载器

	- lib目录

- 扩展类加载器

	- lib/ext

- 应用程序加载器

	- 加载类路径下

- 双亲委派模型

	- 类加载类之前先询问父类是否可以加载，如果可以，由父类加载。这样避免核心的Java基础类被自定义类加载器载入。保证java的基本稳定性。

- 双亲委派模型的三次破坏

	- findClass方法，因为JDK1.2提出双亲委派的时候，有很多自定义的类加载器在使用，自定义类加载器的时候不要重写loadClass方法，而是去重写findClass方法。
	- 例如JNDI这些服务，他们的基础上层类需要下层加载器来加载，所以引入了一个线程上下文加载器。
	- 热部署和热替换，没有使用双亲委派，而是更为复杂的网状结构。

## 虚拟机字节码执行引擎

### 栈帧

- 局部变量表
- 操作数栈
- 动态连接
- 方法返回地址

	- 正常退出
	- 出错

### 方法调用

- 解析

	- invokestatic
	- invokespecial
	- 被final修饰的方法（invokevirtual）

- 分派

	- 静态分派

		- 依赖静态类型来决定方法分配版本的都是，典型的就是方法重载。静态类型指的是外观类型。

	- 动态分派

		- invokevirtual

			- 执行流程

				- 找到操作数栈顶的第一个元素所指向对象的实际类型，然后去匹配方法的简单名称，看是否能够匹配上，如果不能，找这个对象的父类，然后继续pipe

## 对象

### 对象的空间分布

- 对象头
- 实例信息

	- 父类属性在前面
	- 对齐填充

### 访问方式

- 直接指针

	- 因为Java中普遍还是访问对象比访问元类型要多，所以平均下来还是直接指针更快

- 句柄访问

## Java内存模型和线程

### 主内存和工作内存

- lock/unlock
- read/load
- use/assign
- store/write

### volatile

- 保证变量可见性
- 禁止指令重排序优化
- 实现原理

	- use前必须read
	- assign后必须store

- 指令重排序问题

### 原子性

- 前面的8个操作都是原子的

### 可见性

- volatile
- syncronized 

	- unlock某变量前必须把该变量store，write回主内存

- final

### 有序性

- volatile
- syncronized



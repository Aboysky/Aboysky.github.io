[{"categories":["算法"],"content":"动态规划 ","date":"2021-09-18","objectID":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","tags":["算法"],"title":"动态规划","uri":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法"],"content":"5. 最长回文子串 Difficulty: 中等 给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 输入：s = \"babad\" 输出：\"bab\" 解释：\"aba\" 同样是符合题意的答案。 示例 2： 输入：s = \"cbbd\" 输出：\"bb\" 示例 3： 输入：s = \"a\" 输出：\"a\" 示例 4： 输入：s = \"ac\" 输出：\"a\" 提示： 1 \u003c= s.length \u003c= 1000 s 仅由数字和英文字母（大写和/或小写）组成 Solution 分析： 首先如何判定此题用动态规划呢？因为很明显，回文串去掉外层的两个字符，剩下的仍然是回文串，所以可以使用动态规划 。而动态规划有三个问题需要考虑： 1. 状态的定义：stat[i][j]表示string[i:j]范围的字符串是否为回文串。 2. 状态转移方程：stat[i][j] = stat[i + 1][j - 1] \u0026\u0026 s[i] == s[j]; j \u003c s.length; i == j ,true， i + 1 = j, s[i] == s[j] 3. 计算路径： 循环应该从何处开始计算，此题因为所有的长的回文串都需要先计算短的回文串，所以应当按照长度来进行循环，先计算长度为1的回文串，而后在慢慢变大，长度最大为s.length() Language: **** class Solution { public static String longestPalindrome(String s) { boolean [][] stat = new boolean[s.length()][s.length()]; String result = null; int maxLength = 1,pre = 0,end = 0; for (int i = 0;i \u003c stat.length;i++) { stat[i][i] = true; } for (int len = 1; len \u003c= s.length(); len++) { for (int i = 0;i \u003c s.length(); i++) { int j = i + len - 1; if (j \u003e= s.length()) { break; } if (i == j) { stat[i][j] = true; } else if (i + 1 == j) { stat[i][j] = s.charAt(i) == s.charAt(j); } else { stat[i][j] = stat[i+1][j-1] \u0026\u0026 (s.charAt(i) == s.charAt(j)); } if (stat[i][j] \u0026\u0026 j - i + 1 \u003e maxLength) { pre = i; end = j; maxLength = j - i + 1; } } } result = s.substring(pre,end + 1); return result; } } ","date":"2021-09-18","objectID":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:1","tags":["算法"],"title":"动态规划","uri":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法"],"content":"53. 最大子序和 Difficulty: 简单 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1] 输出：1 示例 3： 输入：nums = [0] 输出：0 示例 4： 输入：nums = [-1] 输出：-1 示例 5： 输入：nums = [-100000] 输出：-100000 提示： 1 \u003c= nums.length \u003c= 3 * 10\u003csup\u003e4\u003c/sup\u003e -10\u003csup\u003e5\u003c/sup\u003e \u003c= nums[i] \u003c= 10\u003csup\u003e5\u003c/sup\u003e **进阶：**如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 Solution 思路： 为什么这一题想到用动态规划做？ 最优最大等问题一般都可以考虑用dp 状态定义： 一开始我是想用二元dp，但是发现行不通，因为你根本没有办法递归，然后就没有思路了，但是既然我都想到这个问题了，为什么没有去切换一下思路，换一种状态定义解决这个问题呢？ Language: **** class Solution { public int maxSubArray(int[] nums) { int pre = 0,maxSum = Integer.MIN_VALUE; for (int num : nums) { pre = Math.max(pre + num,num); maxSum = Math.max(pre,maxSum); } return maxSum; } } ","date":"2021-09-18","objectID":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:2","tags":["算法"],"title":"动态规划","uri":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法"],"content":"64. 最小路径和 Difficulty: 中等 给定一个包含非负整数的 _m_ x _n_ 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 **说明：**每次只能向下或者向右移动一步。 示例 1： 输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1→3→1→1→1 的总和最小。 示例 2： 输入：grid = [[1,2,3],[4,5,6]] 输出：12 提示： m == grid.length n == grid[i].length 1 \u003c= m, n \u003c= 200 0 \u003c= grid[i][j] \u003c= 100 Solution Language: **** class Solution { public int minPathSum(int[][] grid) { int m = grid.length,n = grid[0].length; int [][] dp = new int[m][n]; for (int i = 0;i \u003c m;i++) { for (int j = 0;j \u003c n;j++) { if (i == 0 \u0026\u0026 j == 0) { dp[i][j] = grid[i][j]; } else if (i == 0) { dp[i][j] = grid[i][j] + dp[i][j - 1]; } else if (j == 0) { dp[i][j] = grid[i][j] + dp[i - 1][j]; } else { dp[i][j] = Math.min(dp[i - 1][j],dp[i][j - 1]) + grid[i][j]; } } } return dp[m - 1][n - 1]; } } ","date":"2021-09-18","objectID":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:3","tags":["算法"],"title":"动态规划","uri":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法","leetcode","二分查找"],"content":"1011. 在 D 天内送达包裹的能力 Difficulty: 中等 传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。 传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。 返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。 示例 1： 输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5 输出：15 解释： 船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示： 第 1 天：1, 2, 3, 4, 5 第 2 天：6, 7 第 3 天：8 第 4 天：9 第 5 天：10 请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 示例 2： 输入：weights = [3,2,2,4,1,4], D = 3 输出：6 解释： 船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示： 第 1 天：3, 2 第 2 天：2, 4 第 3 天：1, 4 示例 3： 输入：weights = [1,2,3,1,1], D = 4 输出：3 解释： 第 1 天：1 第 2 天：2 第 3 天：3 第 4 天：1, 1 提示： 1 \u003c= D \u003c= weights.length \u003c= 50000 1 \u003c= weights[i] \u003c= 500 Solution Language: Java 暴力枚举： class Solution { public int shipWithinDays(int[] weights, int D) { // int[] privs = new int[weights.length + 1]; int sums = 0; int max = 0; for (int i = 0;i \u003c weights.length;i++) { sums += weights[i]; // privs[i + 1] = privs[i] + weights[i]; max = Math.max(max,weights[i]); } int start = Math.max(sums / D,max); boolean isOk = false; while (true) { int sum = 0; int pD = 1; for (int j = 0;j \u003c weights.length;j++) { sum += weights[j]; if (sum \u003e start) { sum = weights[j]; pD++; } } if (pD \u003c= D) { break; } start++; } return start; } } 二分查找： class Solution { public int shipWithinDays(int[] weights, int D) { // 确定二分查找左右边界 int left = Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum(); while (left \u003c right) { int mid = (left + right) / 2; // need 为需要运送的天数 // cur 为当前这一天已经运送的包裹重量之和 int need = 1, cur = 0; for (int weight : weights) { if (cur + weight \u003e mid) { ++need; cur = 0; } cur += weight; } if (need \u003c= D) { right = mid; } else { left = mid + 1; } } return left; } } 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/solution/zai-d-tian-nei-song-da-bao-guo-de-neng-l-ntml/ 同类型题目： 爱吃香蕉的珂珂 ","date":"2021-04-26","objectID":"/%E5%9C%A8d%E5%A4%A9%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/:0:1","tags":["leetcode","二分查找"],"title":"在D天送达包裹的能力","uri":"/%E5%9C%A8d%E5%A4%A9%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/"},{"categories":["算法","leetcode","栈"],"content":"32. 最长有效括号 Difficulty: ** 示例 1： 输入：s = “(()” 输出：2 解释：最长有效括号子串是 “()” 示例 2： 输入：s = “)()())” 输出：4 解释：最长有效括号子串是 “()()” 示例 3： 输入：s = \"\" 输出：0 提示： 0 \u003c= s.length \u003c= 3 * 104 s[i] 为 ‘(’ 或 ‘)’ ** 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 示例 1： 输入：s = \"(()\" 输出：2 解释：最长有效括号子串是 \"()\" 示例 2： 输入：s = \")()())\" 输出：4 解释：最长有效括号子串是 \"()()\" 示例 3： 输入：s = \"\" 输出：0 提示： 0 \u003c= s.length \u003c= 3 * 10\u003csup\u003e4\u003c/sup\u003e s[i] 为 '(' 或 ')' Solution Language: Java 代码一： /** * 采用栈加上标记 */ class Solution { public int longestValidParentheses(String s) { Stack\u003cInteger\u003e st = new Stack\u003c\u003e(); if (s == null || s.length() == 0) { return 0; } int[] sums = new int[s.length()]; int res = 0,temp = 0; for (int i = 0; i \u003c s.length(); i++) { if (s.charAt(i) == '(') { st.push(i); } else { if (!st.isEmpty()) { sums[st.peek()] = 1; sums[i] = 1; st.pop(); } } } for (int i = 0;i \u003c sums.length;i++) { if (sums[i] == 1) { temp += 1; } else { temp = 0; } res = Math.max(res,temp); } return res; } } 代码二： public class Solution { public int longestValidParentheses(String s) { int maxans = 0; Deque\u003cInteger\u003e stack = new LinkedList\u003cInteger\u003e(); stack.push(-1); for (int i = 0; i \u003c s.length(); i++) { if (s.charAt(i) == '(') { stack.push(i); } else { stack.pop(); if (stack.empty()) { stack.push(i); } else { maxans = Math.max(maxans, i - stack.peek()); } } } return maxans; } } 代码三： /** * dp 我想不完整dp迭代式 */ public class Solution { public int longestValidParentheses(String s) { int maxans = 0; int[] dp = new int[s.length()]; for (int i = 1; i \u003c s.length(); i++) { if (s.charAt(i) == ')') { if (s.charAt(i - 1) == '(') { dp[i] = (i \u003e= 2 ? dp[i - 2] : 0) + 2; } else if (i - dp[i - 1] \u003e 0 \u0026\u0026 s.charAt(i - dp[i - 1] - 1) == '(') { dp[i] = dp[i - 1] + ((i - dp[i - 1]) \u003e= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2; } maxans = Math.max(maxans, dp[i]); } } return maxans; } } ","date":"2021-04-26","objectID":"/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/:0:1","tags":["leetcode","Stack"],"title":"最长有效括号","uri":"/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"},{"categories":["算法","leetcode"],"content":"31. 下一个排列 Difficulty: 中等 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须修改，只允许使用额外常数空间。 示例 1： 输入：nums = [1,2,3] 输出：[1,3,2] 示例 2： 输入：nums = [3,2,1] 输出：[1,2,3] 示例 3： 输入：nums = [1,1,5] 输出：[1,5,1] 示例 4： 输入：nums = [1] 输出：[1] 提示： 1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 100 思路： 看到题之后就感觉很懵，有点搞不清怎么做，主要是还是理不清下一个排列到底怎么产生，也就是没有找到这样的一个规律。直接看官方题解把！ 注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地： - 我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。 - 同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。 以排列 [4,5,2,6,3,1][4,5,2,6,3,1] 为例： 我们能找到的符合条件的一对「较小数」与「较大数」的组合为 22 与 33，满足「较小数」尽量靠右，而「较大数」尽可能小。当我们完成交换后排列变为 [4,5,3,6,2,1][4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6][4,5,3,1,2,6]。 具体地，我们这样描述该算法，对于长度为 nn 的排列 aa： 1. 首先从后向前查找第一个顺序对 (i,i+1)(i,i+1)，满足 a[i] \u003c a[i+1]a[i]\u003ca[i+1]。这样「较小数」即为 a[i]a[i]。此时 [i+1,n)[i+1,n) 必然是下降序列。 2. 如果找到了顺序对，那么在区间 [i+1,n)[i+1,n) 中从后向前查找第一个元素 jj 满足 a[i] \u003c a[j]a[i]\u003ca[j]。这样「较大数」即为 a[j]a[j]。 3. 交换 a[i]a[i] 与 a[j]a[j]，此时可以证明区间 [i+1,n)[i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n)[i+1,n) 使其变为升序，而无需对该区间进行排序。 Solution Language: Java class Solution { public void nextPermutation(int[] nums) { // 我自己写的代码没有他这么优雅，就直接放官方代码了。 int i = nums.length - 2; while (i \u003e= 0 \u0026\u0026 nums[i] \u003e= nums[i + 1]) { i--; } if (i \u003e= 0) { int j = nums.length - 1; while (j \u003e= 0 \u0026\u0026 nums[i] \u003e= nums[j]) { j--; } swap(nums, i, j); } reverse(nums, i + 1); } public void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } public void reverse(int[] nums, int start) { int left = start, right = nums.length - 1; while (left \u003c right) { swap(nums, left, right); left++; right--; } } } 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-04-25","objectID":"/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/:0:1","tags":["leetcode","非常规题"],"title":"下一个排列","uri":"/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"},{"categories":["算法","leetcode"],"content":"23. 合并K个升序链表 Difficulty: 困难 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 解释：链表数组如下： [ 1-\u003e4-\u003e5, 1-\u003e3-\u003e4, 2-\u003e6 ] 将它们合并到一个有序链表中得到。 1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4-\u003e5-\u003e6 示例 2： 输入：lists = [] 输出：[] 示例 3： 输入：lists = [[]] 输出：[] 提示： k == lists.length 0 \u003c= k \u003c= 10^4 0 \u003c= lists[i].length \u003c= 500 -10^4 \u003c= lists[i][j] \u003c= 10^4 lists[i] 按 升序 排列 lists[i].length 的总和不超过 10^4 观题思路 最开始看见题目的时候想法就和合并两个有序链表一样，每次我将n个链表的最小的一个加入res链表中，注意这道题的头节点不确定，所以最好设置一个虚拟的头节点以及插入的tail位置指针。这样想了之后，就需要解决几个问题，第一个包含每个有序链表的当前最前面的节点的容器是什么？可以用题目给你数组，每次将某个链表的当前节点加入res后都更新数组中的值，这样也就有可能导致数组的某一项值为空。第二个就是如何判断哪一个节点是最小值？简单就用循环遍历数组就知道哪一个是最小值了。然后第三个问题就是怎么判断所有节点都已经加入了res了？数组的三个都为空的时候。至此，不考虑最优解的情况下，此题目按理说已经可以写出来了。(代码参见代码一)。 通过上述的解法虽然说是解出来了，但是发现300+ms的运行时间，然后去看了题解，发现很多其他的精彩思路。 首先先想一下上面我们是怎么去拿到每次最小的？是不是每次都需要比k个，有没有方法可以让比较的次数少一点呢？有！答案就是维护一个有序队列，将每个链表的当前节点都放入这个有序队列中，然后拿出队首最小的元素，再将队首最小的元素的下一个放入队列中，这样是不是就省去了每次都去比较。而有序队列在Java中有相关数据结构为PriorityQueue，直接用就好了。(代码参考代码二) 我们都知道怎么去合并两个有序链表，那么n个可不可以转化为合并两个有序数组呢？可以的，先将前两个数组合并，得到结果数组，再将结果数组和后面一个数组合并，依次迭代，则可以得到答案。为了编写方便可以考虑把第一个有序链表就看做就是前面的结果数组。(代码参考代码三)。 上述我们知道了逐个一个一个合并这样就可以拿到最终解决了，但是我们想一想，排序里面，我们除了可以慢慢的将一个数组排成有序，是不是还可以分治，两两间合并。(代码参考代码四) Solution Language: Java 代码一： /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeKLists(ListNode[] lists) { ListNode head = new ListNode(); ListNode point = head; boolean flag = true; while (flag) { flag = false; int tempMin = Integer.MAX_VALUE; int index = 0; for (int i = 0;i \u003c lists.length;i++) { if (lists[i] != null \u0026\u0026 lists[i].val \u003c tempMin) { tempMin = lists[i].val; index = i; flag = true; } } if (flag) { point.next = lists[index]; point = point.next; lists[index] = lists[index].next; } } return head.next;q } } 代码二： class Solution { public ListNode mergeKLists(ListNode[] lists) { ListNode ans = null; for (int i = 0; i \u003c lists.length; ++i) { ans = mergeTwoLists(ans, lists[i]); } return ans; } public ListNode mergeTwoLists(ListNode a, ListNode b) { if (a == null || b == null) { return a != null ? a : b; } ListNode head = new ListNode(0); ListNode tail = head, aPtr = a, bPtr = b; while (aPtr != null \u0026\u0026 bPtr != null) { if (aPtr.val \u003c bPtr.val) { tail.next = aPtr; aPtr = aPtr.next; } else { tail.next = bPtr; bPtr = bPtr.next; } tail = tail.next; } tail.next = (aPtr != null ? aPtr : bPtr); return head.next; } } 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码三： class Solution { public ListNode mergeKLists(ListNode[] lists) { return merge(lists, 0, lists.length - 1); } public ListNode merge(ListNode[] lists, int l, int r) { if (l == r) { return lists[l]; } if (l \u003e r) { return null; } int mid = (l + r) \u003e\u003e 1; return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r)); } public ListNode mergeTwoLists(ListNode a, ListNode b) { if (a == null || b == null) { return a != null ? a : b; } ListNode head = new ListNode(0); ListNode tail = head, aPtr = a, bPtr = b; while (aPtr != null \u0026\u0026 bPtr != null) { if (aPtr.val \u003c bPtr.val) { tail.next = aPtr; aPtr = aPtr.next; } else { tail.next = bPtr; bPtr = bPtr.next; } tail = tail.next; } tail.next = (aPtr != null ? aPtr : bPtr); return head.next; } } 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码四： class Solution { public ListNode mergeKLists(ListNode[] lists) { PriorityQueue\u003cListNode\u003e q = new PriorityQueue\u003c\u003e((x,y)-\u003ex.val-y.val); for(ListNode node : lists){ if(node!=null){ q.add(node); } } ListNode head = new ListNode(0); ListNode tail = head; while(!q.isEmpty()){ tail.next = q.poll(); tail = tail.next; if (tail.next != null){ q.add(","date":"2021-04-25","objectID":"/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/:0:1","tags":["leetcode","分治","优先队列"],"title":"合并K个有序链表","uri":"/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode","动态规划"],"content":"377. 组合总和 Ⅳ Problem Difficulty: 中等 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。 题目数据保证答案符合 32 位整数范围。 示例 1： 输入：nums = [1,2,3], target = 4 输出：7 解释： 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 示例 2： 输入：nums = [9], target = 3 输出：0 提示： 1 \u003c= nums.length \u003c= 200 1 \u003c= nums[i] \u003c= 1000 nums 中的所有元素 互不相同 1 \u003c= target \u003c= 1000 **进阶：**如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？ Solution Language: Java 思路 不知道为什么，最开始又是觉得回溯可以解，但是解出来又是超时，此时才去想回溯的时间复杂度，因为他实际上是求一个排列的问题，所以对于回溯来说，计算了太多无用的内容。 动态规划，令dp[i]的为target=i时的组合数，此时考虑转移函数，当i\u003e0时，dp[i] += dp[i - nums[j]],nums[j]小于等于i，因为对于target = i - nums[j],此时只需要把nums[j]放到排列的后面，则可以组成target=i。考虑边界情况dp[0]，因为要计算dp[1]，所以dp[0] = 1 代码 public int combinationSum4(int[] nums, int target) { int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 1;i \u003c= target;i++) { for (int j = 0;j \u003c nums.length;j++) { if (nums[j] \u003c= i) { dp[i] += dp[i - nums[j]]; } } } return dp[target]; } ","date":"2021-04-24","objectID":"/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Civ/:0:1","tags":["leetcode","动态规划"],"title":"组合总和IV","uri":"/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Civ/"},{"categories":["leetcode","动态规划"],"content":"368. 最大整除子集 题目 Difficulty: 中等 给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足： answer[i] % answer[j] == 0 ，或 answer[j] % answer[i] == 0 如果存在多个有效解子集，返回其中任何一个均可。 示例 1： 输入：nums = [1,2,3] 输出：[1,2] 解释：[1,3] 也会被视为正确答案。 示例 2： 输入：nums = [1,2,4,8] 输出：[1,2,4,8] 提示： 1 \u003c= nums.length \u003c= 1000 1 \u003c= nums[i] \u003c= 2 * 10\u003csup\u003e9\u003c/sup\u003e nums 中的所有整数 互不相同 Solution Language: Java 思路： 最开始看到题目的时候第一时间想到的回溯分析，因为回溯对于这类选择问题绝对是可以做的，因为他是一个暴力匹配，所以后续就在想有没有什么很好的剪枝方法，但是并没有找到好的剪枝方法。 由于回溯的时间复杂度太高，只能考虑使用动态规划，而使用动态规划第一个就是要考虑定义一个什么状态，此题是叫我们求最长的整除子集，按照一般经验，此时我们应该定义dp[i]表示为在nums中前i位的最长整除子集长度。定义了状态后考虑状态转移函数，dp[i] = Math.max(dp[0 - j] + 1,dp[i]),而dp[0-j]表示nums[i] % nums[j] == 0时j的dp; (i \u003e= 1)，思考一下，如何才能保证nums[i] % nums[j] == 0时就可以保证nums[i]可以添加进入前面的集合？答案是将nums数组排序，因为后面的肯定比前面的大，也就是每次都是和子集的最大元素比较，如果当前元素能够整除子集的最大元素，则一定可以加入这个子集。在转移方程确定后，我们需要考虑的是如何将这个最长的整除子集返回，也就是如何拿到这个整除子集。可以考虑倒推法。也就是我们维护一个变量maxSize(==dp[i])和maxVal(==nums[i])，而后从后往前遍历dp数组，当dp[i] == maxSize时，如果maxVal % nums[i] == 0，那么表明maxSize和maxVal所记录的最大整除子集的最后一个就是这一个。而后将这个添加进入res，此后将maxSize--;maxVal = nums[i],循环下去，则能够找到所有的节点。 代码： class Solution { public List\u003cInteger\u003e largestDivisibleSubset(int[] nums) { Arrays.sort(nums); int len = nums.length; int[] dp = new int[len]; Arrays.fill(dp,1); int maxSize = 1; int maxVal = 0; for (int i = 1;i \u003c len;i++) { for (int j = 0;j \u003c i;j++) { if (nums[i] % nums[j] == 0) { dp[i] = Math.max(dp[i],dp[j] + 1); } } if (dp[i] \u003e maxSize) { maxSize = dp[i]; maxVal = nums[i]; } } List\u003cInteger\u003e res = new ArrayList\u003c\u003e(); for (int i = len - 1;i \u003e= 0;i--) { if (dp[i] == maxSize \u0026\u0026 maxVal % nums[i] == 0){ res.add(nums[i]); maxSize--; maxVal = nums[i]; } } return res; } } ","date":"2021-04-23","objectID":"/%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/:0:1","tags":["leetcode","动态规划"],"title":"最大整除子集","uri":"/%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/"},{"categories":null,"content":"你好呀！ 感谢相遇！从此，世界上多了一分痕迹！ 热爱 - 坚持 = 一时兴起 热爱 + 坚持 = 自我 热爱 + 坚持 + Random = 世俗成功 热爱自身所向往的！ 愿大家都心里有火，眼里有光！ ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"about","uri":"/about/"},{"categories":null,"content":"1.理念 一次构建,随处运行 解决运行环境和配置问题软件容器,方便做持续集成并有助于整体发布的容器虚拟化技术 和虚拟机的区别 ","date":"0001-01-01","objectID":"/docker/:1:0","tags":null,"title":"Docker","uri":"/docker/"},{"categories":null,"content":"2.docker组成 架构图: 基本组成: 镜像: 类似于Java的类,可以创建多个对象(也就是docker的容器) 镜像是分层的 容器 Docker利用容器(Container)独立运行的一个或一组应用.容器时用镜像创建的运行实例. 容器可以被启动,开始,停止,删除.每个容器都是相互隔离的,保证安全的平台. 可以把容器看作以简易版的Linux环境(包括root用户权限,进程空间,用户空间,和网络空间等)和运行在其中的应用程序,容器的定义 和镜像几乎一模一样,也是一堆层的统一视角.唯一区别在于容器的最上面那一层是可读可写的. 仓库 ","date":"0001-01-01","objectID":"/docker/:2:0","tags":null,"title":"Docker","uri":"/docker/"},{"categories":null,"content":"3.底层原理 run执行过程 为什么Docker比VM快? ","date":"0001-01-01","objectID":"/docker/:3:0","tags":null,"title":"Docker","uri":"/docker/"},{"categories":null,"content":"4.Docker常用命令 文档 Usage: docker [OPTIONS] COMMAND A self-sufficient runtime for containers Options: --config string Location of client config files (default \"/root/.docker\") -c, --context string Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with \"docker context use\") -D, --debug Enable debug mode -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level (\"debug\"|\"info\"|\"warn\"|\"error\"|\"fatal\") (default \"info\") --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default \"/root/.docker/ca.pem\") --tlscert string Path to TLS certificate file (default \"/root/.docker/cert.pem\") --tlskey string Path to TLS key file (default \"/root/.docker/key.pem\") --tlsverify Use TLS and verify the remote -v, --version Print version information and quit Management Commands: builder Manage builds config Manage Docker configs container Manage containers context Manage contexts engine Manage the docker engine image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumes Commands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codes 帮助命令: 镜像命令: docker images 列出本机镜像文件 常用参数说明: -a:列出本地所有的镜像(含中间映像层) -q:只显示镜像ID --digests: 显示镜像的摘要信息 --no-trunc:显示完整的镜像信息 docker search` docker search 镜像名字 去hub.docker上面查有哪些镜像 参数说明: --no-trunc:显示完整的镜像描述 -s:列出收藏数不小于指定值的镜像 --automated:只列出automated build类型的镜像 docker pull 镜像名 docker [options] pull 镜像名 [:tags] 如果不加后面的tag,那么默认是latest最新版本. docker rmi 某个xxx镜像名字ID [tag] 删除镜像 不加后面的tag默认删除latest 删除单个 docker rmi 镜像名 删除多个 docker rmi -f(强制) 镜像名1:tag 镜像名2:tag 删除全部 docker rmi -f $(docker images -qa) 容器命令 docker run [Options] image [command] 创建并启动容器 常用选项: docker ps [OPTIONS] 列出当前所有正在运行的容器 退出容器 exit 容器停止后退出,也就是下次使用得重启 ctrl+P+Q 容器不停止退出,下次可以继续使用,只是暂时退出 开启容器 docker start 容器名/id 重启容器 docker restart 容器名/id 停止容器 docker stop 容器名/id 正常关机 强制停止 docker kill 容器名/id 类似于直接拔电源 删除已停止的容器 docker rm 容器ID ","date":"0001-01-01","objectID":"/docker/:4:0","tags":null,"title":"Docker","uri":"/docker/"},{"categories":null,"content":"5.Docker镜像 概念: 镜像是一种轻量级,可执行的独立软件包,用来打包软件运行环境和基于运行环境开发的软件,它包含运行某个软件所需的所有内容,包括代码,运行时,库,环境变量和配置文件. UnionFS联合文件系统 docker镜像加载原理 镜像分层的概念(以tomcat为什么这么大为路径) 因为联合文件系统UnionFS,tomcat需要包含它所有他所需的底层环境,一层一层这样叠加起来,就会变得很大 为什么docker要采用多层镜像? 最大的好处 -共享资源 特点: 补充: ","date":"0001-01-01","objectID":"/docker/:5:0","tags":null,"title":"Docker","uri":"/docker/"},{"categories":null,"content":"Docker容器数据卷 ","date":"0001-01-01","objectID":"/docker/:6:0","tags":null,"title":"Docker","uri":"/docker/"},{"categories":null,"content":"概念: 其实也就是相当于在容器和系统之间建立一个可以同步共享的文件夹, ","date":"0001-01-01","objectID":"/docker/:6:1","tags":null,"title":"Docker","uri":"/docker/"},{"categories":null,"content":"作用: ","date":"0001-01-01","objectID":"/docker/:6:2","tags":null,"title":"Docker","uri":"/docker/"},{"categories":null,"content":"创建容器数据卷: 命令行添加: docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名 限制容器内对这个数据卷也就是文件夹只读不可写: docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名 DokcerFile添加: 步骤: 1. 新建一个文件夹,并且在文件夹下创建一个名为Dockerfile的文件 2. 然后将要添加的dockerfile文件的内容写入保存 3. 然后将这个dockerfile文件和原始centos镜像通过docker build命令重新组装一个新镜像. 4. 然后用这个新镜像创建一个容器,容器中自动创建了我们定义好的那两个数据卷. 5. 可以通过用docker inspect 容器id 来查看容器的详细描述,里面有数据卷对应的主机目录. ","date":"0001-01-01","objectID":"/docker/:6:3","tags":null,"title":"Docker","uri":"/docker/"},{"categories":null,"content":"数据卷容器: 如下图,也就是将dc01的数据卷与dc02共享,也就是在dc01中改变,dc02中也可以查看 !!!注意: 1. 假如dc01有两个共享,也就是dc02和dc03都继承与dc01,那么将dc01删除后,dc02和dc03还有共享吗? 仍然共享,不受影响,只要共享一建立,就和其他任何其他容器没有任何关系 比如dc3继承dc2,dc2继承dc1,将dc2删除,那么dc1和dc3之间仍然能够共享,不会受到任何影响. ","date":"0001-01-01","objectID":"/docker/:6:4","tags":null,"title":"Docker","uri":"/docker/"},{"categories":null,"content":"Dockerfile ","date":"0001-01-01","objectID":"/docker/:7:0","tags":null,"title":"Docker","uri":"/docker/"},{"categories":null,"content":"概念: dockerfile是用来构建docker镜像的构架文件,是由一系列的命令和参数构成的脚本. 构建的三个步骤: dockerfile -\u003e docker build -\u003e run ","date":"0001-01-01","objectID":"/docker/:7:1","tags":null,"title":"Docker","uri":"/docker/"},{"categories":null,"content":"构建过程: ","date":"0001-01-01","objectID":"/docker/:7:2","tags":null,"title":"Docker","uri":"/docker/"},{"categories":null,"content":"Docker体系结构(指令) copy 后面的参数有两种写法 copy src dest copy[\"src\",\"dest\"] ","date":"0001-01-01","objectID":"/docker/:7:3","tags":null,"title":"Docker","uri":"/docker/"},{"categories":null,"content":"案例 案例1: vim和ifconfig支持 ","date":"0001-01-01","objectID":"/docker/:7:4","tags":null,"title":"Docker","uri":"/docker/"},{"categories":null,"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. ","date":"0001-01-01","objectID":"/hello-world/:0:0","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Quick Start ","date":"0001-01-01","objectID":"/hello-world/:1:0","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Create a new post $ hexo new \"My New Post\" More info: Writing ","date":"0001-01-01","objectID":"/hello-world/:1:1","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Run server $ hexo server More info: Server ","date":"0001-01-01","objectID":"/hello-world/:1:2","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Generate static files $ hexo generate More info: Generating ","date":"0001-01-01","objectID":"/hello-world/:1:3","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Deploy to remote sites $ hexo deploy More info: Deployment ","date":"0001-01-01","objectID":"/hello-world/:1:4","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Java并发 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:0:0","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"线程 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:1:0","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"线程和进程的区别 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:1:1","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"创建线程的方式 其实新建线程的方式就只有一种，就是Thread类的Start0方法，但是这个方法是一个private native方法。并且这个方法也只在start方法中被调用到了。而start方法他的执行逻辑是先去判断这个线程有没有执行过start方法，有一个状态位，如果没有，就去调用start0方法。start0方法是一个本地方法，他在里面去回调run方法。 所以创建线程的方法只有这个start0方法。 继承Thread类重写run方法 实现Runnable接口 Callable Future接口定义一个规则，就是可以取值和取消任务，然后就是RunnableFuture，它实现了Runable和Future，最后就是FutureTask，它实现了RunnableFuture，一般Callable其实还是去通过Thread或者线程池的submit去提交一个任务 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:1:2","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"线程的状态转换 NEW、RUNNABLE、WAIT、TIME_WAIT、BLOCKED、TERMINATED wait、LockSupport.park() ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:1:3","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"基本API yield sleep TimeUnit.sleep join start run ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:1:4","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"怎么去停止线程？ 不推荐的方式 stop 、suspend 中断 interrupt isInterrupt()方法 重载，如果参数设置为true，则会清除中断标记，而interrupted方法则是调用了这个方法 interrupted() 方法，会还原中断标记 标志对象 volatile ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:1:5","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"线程同步的基本方法 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:2:0","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"CAS(Compare and swap) 比较并交换，AQS和偏向锁，原子类，类的初始化等等都用的是这个 基于cmpxchg指令 缺点 ABA问题，增加版本号 空自旋等待成功 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:2:1","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"volatile 功能 保证可见性 禁止重排序 实现 可见性的保证 jvm层面 ，use前read，write后store cpu层面 因为volatile关键字主要是去实现共享变量的可见性，在cpu执行中，cpu并不直接向内存交换数据，而是和缓存行，也就是cpu拿和修改数据都是在缓存行里面。这个时候就会有一个问题，不同cpu中的L1,L2缓存中可能不一样。而volatile关键字在底层主要就是在指令前加了lock前缀，而lock前缀最关键的作用就是会引起处理器缓存回写到内存。一个处理器的缓存回写到内存会导致其他处理器的缓存无效。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的 缓存的数据在总线上保持一致。 禁止重排序的实现 内存屏障 happens-before 一个volatile对象的写，happens-before任何后续对这个volatile对象的读 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:2:2","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"syncronized 功能 原子性 可见性 可重入性 实现 普通同步方法 静态同步方法 同步代码块 monitorenter monitorexit 原理 不管是monitorenter这些指令还是ACC_SYNCRONOUS标志，他们的目的都只是一个，判别这是一个同步方法，去要去控制线程同步。此时他们都会去找此对象关联的monitor对象，尝试去acquire这个监视器。如果拿到了就进去，如果没有拿到，则进入这个monitor负责的阻塞队列中。 前面的也不一定准备，因为jdk1.6的时候对这个做了优化，增加了偏向锁，轻量级锁。所以你进去的时候会先尝试偏向锁，然后再试后面的。锁升级 锁升级 无锁 偏向锁 大部分时候都是一个线程在访问。。。只需要比较线程id是否一致，。。 先看偏向锁指向的线程id是否存活，不存活的话直接cas改掉线程id，获得锁，存活则看它是否需要继续争抢锁，如果争抢，升级为轻量级锁，或者判断epoch的大小是否超过40，如果超过，也升级为轻量级锁。 轻量级锁 轻量级锁的主要思想就是大部分的锁立马就可以拿到，如果直接去阻塞然后唤醒，因为需要转换内核和用户态，那效率就很低，所以他就自旋等待，一般是10次，如果没有拿到，升级为重量锁，或者自旋等待时又有一个线程来抢，则立马升级为重量锁。jdk后续将自旋锁改为了自适应自旋锁，也就是等待时间可以参考前面是否有线程自旋等待成功。如果有，就等久一点 重量级锁 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:2:3","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"Lock ReentrantLock ReentrantRedaWriteLock ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:2:4","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"Java内存模型 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:3:0","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"概述 Java它想建立一个抽象的高级的内存模型，以去抵消掉不同的底层所带来的影响。方便程序员的编写。他不是一个具体的实现，他更多的是一种规范，去声明和指定以及保证多个线程正确的同步执行。 它对于多线程，每一个线程都有一个自己的本地内存，这个本地存储是每个线程独享的，然后他们有一个共享内存，一般就是堆。而本地内存和主内存之间的数据交换就是由JMM控制。 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:3:1","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"原子性 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:3:2","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"有序性 双重检查锁定 由于对象new时分配空间，初始化，将地址空间传递给对象，二三步的执行顺序并不一定就是这样，所以可能导致访问到未被正确初始化的对象。 解决办法 volatile 借助于类初始化的锁机制，用静态内部类初始化一个 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:3:3","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"可见性 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:3:4","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"happens-before原则 程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。 锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。 volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。 线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见 传递性 A先于B ，B先于C 那么A必然先于C 线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。 线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。 对象终结规则 对象的构造函数执行，结束先于finalize()方法 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:3:5","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"final内存语义 禁止把final域的写重排序到构造函数之外，可以保证在对象引用为任意线程可见之前,对象的final域已经被正确初始化过了 初次读对象引用与初次读该对象包含的final 域, ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:3:6","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"锁 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:4:0","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"Lock接口 /* ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. /* * * * * * Written by Doug Lea with assistance from members of JCP JSR-166 Expert Group and released to the public domain, as explained at http://creativecommons.org/publicdomain/zero/1.0/ */ package java.util.concurrent.locks; import java.util.concurrent.TimeUnit; /** {@code Lock} implementations provide more extensive locking operations than can be obtained using {@code synchronized} methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated {@link Condition} objects. A lock is a tool for controlling access to a shared resource by multiple threads. Commonly, a lock provides exclusive access to a shared resource: only one thread at a time can acquire the lock and all access to the shared resource requires that the lock be acquired first. However, some locks may allow concurrent access to a shared resource, such as the read lock of a {@link ReadWriteLock}. The use of {@code synchronized} methods or statements provides access to the implicit monitor lock associated with every object, but forces all lock acquisition and release to occur in a block-structured way: when multiple locks are acquired they must be released in the opposite order, and all locks must be released in the same lexical scope in which they were acquired. While the scoping mechanism for {@code synchronized} methods and statements makes it much easier to program with monitor locks, and helps avoid many common programming errors involving locks, there are occasions where you need to work with locks in a more flexible way. For example, some algorithms for traversing concurrently accessed data structures require the use of \"hand-over-hand\" or \"chain locking\": you acquire the lock of node A, then node B, then release A and acquire C, then release B and acquire D and so on. Implementations of the {@code Lock} interface enable the use of such techniques by allowing a lock to be acquired and released in different scopes, and allowing multiple locks to be acquired and released in any order. With this increased flexibility comes additional responsibility. The absence of block-structured locking removes the automatic release of locks that occurs with {@code synchronized} methods and statements. In most cases, the following idiom should be used: {@code Lock l = …; l.lock(); try { // access the resource protected by this lock } finally { l.unlock(); }} When locking and unlocking occur in different scopes, care must be taken to ensure that all code that is executed while the lock is held is protected by try-finally or try-catch to ensure that the lock is released when necessary. {@code Lock} implementations provide additional functionality over the use of {@code synchronized} methods and statements by providing a non-blocking attempt to acquire a lock ({@link #tryLock()}), an attempt to acquire the lock that can be interrupted ({@link #lockInterruptibly}, and an attempt to acquire the lock that can timeout ({@link #tryLock(long, TimeUnit)}). A {@code Lock} class can also provide behavior and semantics that is quite different from that of the implicit monitor lock, such as guaranteed ordering, non-reentrant usage, or deadlock detection. If an implementation provides such specialized semantics then the implementation must document those semantics. Note that {@code Lock} instances are just normal objects and can themselves be used as the target in a {@code synchronized} statement. Acquiring the monitor lock of a {@code Lock} instance has no specified relationship with invoking any of the {@link #lock} methods of that instance. It is recommended that to avoid confusion you never use {@code Lock} instances in this way, except within their own implementation. Except where noted, passing a {@code null} value for any parameter will result in a {@link NullPointerException} being thrown. Memory Synchronization All {@code Lock} imple","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:4:1","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"队列同步器AbstractQueueSynchronizer 获取状态的方法 getState SetState CompareAndSet 需要重写的方法 提供的模板方法 同步队列 Node FIFO的双向队列，只有他的前驱节点为头节点才有资格去尝试获取锁，如果获取到之后，将自己设置为头节点，然后将原头节点的next指针设置为空。 独占式获取锁 public final void acquire(int arg) { if (!tryAcquire(arg) \u0026\u0026 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 将节点添加进同步队列 private Node addWaiter(Node mode) { Node node = new Node(mode); for (;;) { Node oldTail = tail; if (oldTail != null) { node.setPrevRelaxed(oldTail); if (compareAndSetTail(oldTail, node)) { oldTail.next = node; return node; } } else { initializeSyncQueue(); } } } 在队列中的节点不断的获取锁 final boolean acquireQueued(final Node node, int arg) { boolean interrupted = false; try { for (;;) { // 获取前驱节点 final Node p = node.predecessor(); if (p == head \u0026\u0026 tryAcquire(arg)) { setHead(node); p.next = null; // help GC return interrupted; } if (shouldParkAfterFailedAcquire(p, node)) interrupted |= parkAndCheckInterrupt(); } } catch (Throwable t) { cancelAcquire(node); if (interrupted) selfInterrupt(); throw t; } } 独占式释放锁 public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null \u0026\u0026 h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } private void unparkSuccessor(Node node) { /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws \u003c 0) node.compareAndSetWaitStatus(ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus \u003e 0) { s = null; //倒序遍历，找到最先的一个waitStatus小于等于0的node for (Node p = tail; p != node \u0026\u0026 p != null; p = p.prev) if (p.waitStatus \u003c= 0) s = p; } if (s != null) LockSupport.unpark(s.thread); } 为什么需要倒序遍历寻找？ 因为addWaiter时的操作并不是原子操作，可能出现前置指针好了，但是后指针没有指成功。并且canceled也是将后指针指向了自己，所以倒序遍历寻找最好 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:4:2","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"ReentrantLock 可重入锁 公平和非公平锁 ReentrantLock 分为公平锁和非公平锁，可以通过构造方法来指定具体类型： public ReentrantLock() { sync = new NonfairSync(); } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } 默认一般使用非公平锁，它的效率和吞吐量都比公平锁高的多(后面会分析具体原因)。 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:4:3","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"ReentrantReadWriteLock 同步状态 前16位标识读，后16位标识写 锁降级 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:4:4","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"LockSupport类 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:4:5","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"Condition接口 类似于Object对象的wait/notify方法 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:4:6","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"ConditionObject 是aqs下的一个内部类 等待队列 FIFO的队列 同步队列入等待队列 从等待队列移入同步队列 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:4:7","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"并发容器 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:5:0","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"ConcurrentHashMap jdk1.7 segment数组加上entry数组，segment实现的时ReentrantLock，来实现分段锁 jdk1.8 Node static class Node\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e { final int hash; final K key; volatile V val; volatile Node\u003cK,V\u003e next; put public V put(K key, V value) { return putVal(key, value, false); } final V putVal(K key, V value, boolean onlyIfAbsent) { // key value都不能为空 if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; for (Node\u003cK,V\u003e[] tab = table;;) { Node\u003cK,V\u003e f; int n, i, fh; K fk; V fv; if (tab == null || (n = tab.length) == 0) // 第一次插入的时候初始化 tab = initTable(); // 如果这个node没有值的话，直接插入进去 else if ((f = tabAt(tab, i = (n - 1) \u0026 hash)) == null) { if (casTabAt(tab, i, null, new Node\u003cK,V\u003e(hash, key, value))) break; // no lock when adding to empty bin } // hash位moved说明它正在扩容，然后去帮助扩容 else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else if (onlyIfAbsent // check first node without acquiring lock \u0026\u0026 fh == hash \u0026\u0026 ((fk = f.key) == key || (fk != null \u0026\u0026 key.equals(fk))) \u0026\u0026 (fv = f.val) != null) return fv; else { V oldVal = null; synchronized (f) { if (tabAt(tab, i) == f) { if (fh \u003e= 0) { binCount = 1; for (Node\u003cK,V\u003e e = f;; ++binCount) { K ek; if (e.hash == hash \u0026\u0026 ((ek = e.key) == key || (ek != null \u0026\u0026 key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node\u003cK,V\u003e pred = e; if ((e = e.next) == null) { pred.next = new Node\u003cK,V\u003e(hash, key, value); break; } } } else if (f instanceof TreeBin) { Node\u003cK,V\u003e p; binCount = 2; if ((p = ((TreeBin\u003cK,V\u003e)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } else if (f instanceof ReservationNode) throw new IllegalStateException(“Recursive update”); } } if (binCount != 0) { if (binCount \u003e= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } addCount(1L, binCount); return null; } //初始化数组 private final Node\u003cK,V\u003e[] initTable() { Node\u003cK,V\u003e[] tab; int sc; while ((tab = table) == null || tab.length == 0) { // 说明有数组正在初始化 if ((sc = sizeCtl) \u003c 0) Thread.yield(); // lost initialization race; just spin else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) { try { if ((tab = table) == null || tab.length == 0) { int n = (sc \u003e 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(“unchecked”) Node\u003cK,V\u003e[] nt = (Node\u003cK,V\u003e[])new Node[n]; table = tab = nt; sc = n - (n »\u003e 2); } } finally { sizeCtl = sc; } break; } } return tab; } get 扩容 扩容有两个时机进行扩容，一个是某个node的长度大于等于8的时候，他就会调用treeIfyBin方法去尝试是否可以树化，这个方法首先会判断node数组的长度，如果小于64，则考虑先将数组扩容。tryPreSize方法进行扩容。这个方法里面则会调用transfer方法来进行扩容，transfer方法负责迁移node节点，他有一个transferIndex指针，最开始时这个指针指向数组最右端，通过这个指针和每次每个线程需要迁移的node数，迁移的node数最少为16，然后将index指针cas修改掉，并且将已经迁移好的node节点变为forwardingNode，如果这个时候有线程访问，如果这个线程是去put或者remove方法，那么他会调用helptransfer方法来帮助扩容。如果进去方法后发现index指针为0或者扩容线程已经到最大的线程数，则直接返回。如果时get则会去调用forwardingIndex中的find方法访问新的node数组中对应的值。 cas加上syncronized ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:5:1","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"CopyOnWriteArrayList 所有对数组有修改的操作都在新数组在进行，也就是用空间换时间。 它重写了一个COWIterator内部类，内部迭代的可能只是一个快照而已。 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:5:2","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"ThreadLocal 每一个Thread里面都有一个threadlocals对象，这个对象的类型是ThreadLocal.ThreadLocalMap类型的对象，ThreadLocalMap内部是一个Entry数组，而Entry是ThreadLocalMap的一个静态内部类，它继承了WeakReference\u003cThreadLocal\u003e类型，Entry增加了一个内部属性value。因为线程和ThreadLocal之间的引用是弱引用，所以当线程使用完成后gc时就会自动回收这个对象，避免内存泄漏。 get set remove ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:5:3","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"CountDownLatch 倒数计数器，构造方法传入一个整型值，主线程通过await方法阻塞，直到活动线程多次调用countdown方法将state的状态减为0时主线程结束休眠。底层使用的是aqs的共享锁。当state不为0时，表示都可以获取共享锁。await可以多个线程调用，然后都被阻塞到同步队列中。countdown一个线程也可以调用多次 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:5:4","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"CyclicBarrier 可以循环使用的障碍，创建此对象时可以传入一个整形值和一个Runable对象，代表在这个障碍前需要多少个线程到达，也就是需要被调用多少次await方法的线程等待在这个障碍前。内部使用的是非公平的ReentrantLock ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:5:5","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"Exchanger 用于两个线程间交互信息，当线程调用exchange方法后阻塞，直到另一个线程调用exchange方法 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:5:6","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"线程池 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:6:0","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"概念 是一种基于池化思想管理线程的工具 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:6:1","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"好处 降低资源消耗：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。 提高响应速度：任务到达时，无需等待线程创建即可立即执行。 提高线程的可管理性：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。 提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:6:2","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"总体设计 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:6:3","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"生命周期管理 ctl属性 workercounter runstate 线程池状态转换 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:6:4","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"任务调度 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:6:5","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"拒绝策略 ","date":"0001-01-01","objectID":"/java%E5%B9%B6%E5%8F%91/:6:6","tags":["并发","Java"],"title":"Java并发基本理论","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"JVM ","date":"0001-01-01","objectID":"/jvm/:0:0","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"基于栈的指令集架构和基于寄存器的指令集架构 ","date":"0001-01-01","objectID":"/jvm/:1:0","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"栈 同样操作指令更多，因为有许多入栈出栈操作指令，但是指令一般不带参数。并且由于栈在内存中，肯定比不上寄存器的访问速度。 ","date":"0001-01-01","objectID":"/jvm/:1:1","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"空间分布 ","date":"0001-01-01","objectID":"/jvm/:2:0","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"线程公有 堆 方法区 在HotSpot虚拟机上，1.7之前一般就默认称为永久代，因为HotSpot虚拟机将这块内存一起纳入了垃圾回收机制的范围，但是由于JVM内存有总量限制，所以在1.7开始就逐渐把原本属于永久代的东西移到本地内存，但是1.7中常量池，静态变量等还是在方法区，1.8后移入堆中，永久代彻底消失。 运行时常量池 主要用来存放编译期生成的各种字面量和符号引用。但是也可以存放在运行期添加进入的，由于他在方法区，所以仍然可能产生OOM。 ","date":"0001-01-01","objectID":"/jvm/:2:1","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"线程私有 程序计数器 虚拟机栈 每个方法被执行的时候，都会自动创建一个栈帧，其中包括局部变量表，操作数栈，动态连接，方法出口等等。 局部变量表 局部变量槽Slot long double占两个 异常 StackOverFlowError 申请栈帧的数量超过虚拟机允许的最大深度 OutOfMemoryError 总栈帧占的地址空间大于最大的栈空间，由于HotSpot虚拟机不支持栈容量动态扩展，所以发生OOM只可能在新建线程给线程分配堆缓冲池时TLAB。 -Xss 本地方法栈 异常 StackOverFlowError 申请栈帧的数量超过虚拟机允许的最大深度 OutOfMemoryError 总栈帧占的地址空间大于最大的栈空间 ","date":"0001-01-01","objectID":"/jvm/:2:2","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"直接内存 DirectByteBuffer 由于主机内存有限制，所以也可能产生OOM ","date":"0001-01-01","objectID":"/jvm/:2:3","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"垃圾回收 ","date":"0001-01-01","objectID":"/jvm/:3:0","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"哪些对象需要回收？已经“死”去的对象 引用计数法（可能造成循环引用） 可达性分析 GC Roots 虚拟机栈中引用的对象 方法区中类静态属性的引用 方法区中常量引用 synchronized持有的对象 临时的对象 引用 四种引用类型 强引用 new 出来的都是强引用，如果一个对象被强引用引用，当内存不够时，jvm宁愿爆出oom，也不愿意将拥有强引用引用的对象回收。 软引用 （SoftReference） 软引用是引用强度上仅次于强引用的，他的类是public，只有强引用的类是仅包内可见的。软引用的对象在jvm内存资源充足的时候不会被回收，但是内存资源紧张的时候会被回收。一般可以用来作为缓存区的引用。 弱引用（WeakReference） 弱引用是最弱的一种可以直接取到链接对象值的一个引用，在gc时，jvm碰到弱引用则直接回收。有一个用在内存敏感的WeakHashMap就是用的WeakReference，它通过监控ReferenceQueue来完成Entry的清洗。 虚引用/幽灵引用（PhantomReference） 最弱的引用，不能直接访问到对象，一般可以用来通知某个对象是否被回收。他有一个子类，Cleaner，用来负责对DirectByteBuffer的回收，创建DirectByteBuffer对象时会创建一个Cleaner对象，Cleaner对象持有了DirectByteBuffer对象的引用。当JVM在GC时，如果发现DirectByteBuffer被地方法没被引用啦，JVM会将其对应的Cleaner加入到pending-reference链表中，同时通知ReferenceHandler线程处理，ReferenceHandler收到通知后，会调用Cleaner#clean方法，而对于DirectByteBuffer创建的Cleaner对象其clean方法内部会调用unsafe.freeMemory释放堆外内存。最终达到了DirectByteBuffer对象被GC回收其对应的堆外内存也被回收的目的。 类卸载 该类没有任何实例 加载该类的类加载器已经被回收 Class类没有在任何地方被引用 可达性分析之后如果被标记为不可达，此时将对对象进行第一次标记，然后判断对象是否有必要执行finalize方法，如果有必要，则将其加入F-Queue队列，这个队列将由一个jvm自动建立的低优先级的线程去执行他们的finalize方法，这里说的执行是虚拟机会保证他执行，但是不保证他执行完，因为有可能这里执行缓慢或者死循环。然后将会对这里的对象进行第二次小规模的标记，如果有可以被连接上的，则将其移除这个即将被回收的集合 ","date":"0001-01-01","objectID":"/jvm/:3:1","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"垃圾收集算法 分代收集理论 弱分代假说 大部分对象都是朝生夕灭 强分代假说 熬过越多次垃圾回收就越难消亡 跨代引用假说 跨代引用相对于同代引用来说终究是少数 记忆集 新生代上建立一个数据结构，将老年代分为一块一块的，他指明老年代的哪些块有跨代引用。这个需要每次改变引用时都维护这个数据集的正确性，但是相比于gc时扫描全部老年代来说划算的多 垃圾回收算法 标记清除算法 标记存活的或者死亡的，然后清除。 缺点： 执行效率不稳定，内存空间的碎片化 标记-复制算法 将空间分为两块或以上，标记存活的对象，然后将存活的对象整体移动到另外一块内存上，这样分配内存的时候就只需要移动指针就可以了。 HotSpot的Serial，ParNew等新生代回收器都采用了这种。他们的内存划分为三块，一块较大的Eden（80%），两块小的survivor（10%一块），每次只使用一块Eden和一块survivor。 分配担保: 假如10%的区域不够，则分配到老年代，由老年代进行分配担保。 标记-整理算法 标记存活的，然后将其移动到一起。防止内存碎片化。 因为需要移动对象，所以相对来说垃圾回收会比较复杂，但是如果移动，那么对象的分配就会更加复杂。相比来说，如果更加关注吞吐量，那么就选择移动，因为HotSpot中关注吞吐量的Parallel Scavenge是选择标记整理算法的。但是关注延迟的CMS是标记-清除算法的。但是CMS的策略是暂时容忍内存碎片，等到它已经影响到分配对象时，则再用标记-整理算法清理一遍。 HosSpot垃圾回收算法实现 根节点枚举 因为根节点枚举需要系统中准确的全部的引用，所以这一个地方需要暂停所有的用户线程。‘ 准确式内存管理： 明确知道栈中或者某地方的变量中到底是值还是引用。 OopMap 准确的记录了哪些地方存放着对象引用 安全点 因为导致OopMap变化的指令非常多，jvm不可能在每一个指令都去更改OopMap，这样就出现了安全点，在这块区域，指令的更改将会导致OopMap的更新。因此安全点选取的标准就是是否具有让程序长时间执行的特征。 如果让所有的线程跑到安全点上停止下来？ 抢先式中断 先把所有用户程序暂停，如果发现某个线程不在安全点，则让他再运行一会，然后中断，直到它在安全点，但是基本上没有jvm采用这种方法 主动式中断 轮询标志位，标志位一般和安全点在一个地方，再加上需要分配堆空间的地方。当标志位为真时，则到最近的一个安全点主动中断挂起。因为轮询非常普遍，所以要求足够精简。一般是通过test指令来测试访问标志位，如果不能访问成功，则产生一个自陷异常信号，然后交给预先注册的异常处理器中处理。 安全区域 当一些线程在阻塞或是sleep的时候，线程不能走到最近的安全点，但jvm也不可能等到阻塞的线程直到执行才开始回收。所以就有了安全区域，当线程进入安全区域时，他会标志自己进入了安全区域，安全区域就是这段代码不会影响到引用的改变。当阻塞或者sleep的线程想要从安全区域出来继续运行的时候，需要先判断类如根节点枚举或者其他需要暂停用户线程的这些阶段是否完成，如果完成了，才能继续执行，否则继续在安全区域等待。直到收到可以离开安全区域的信号为止 记忆集 卡表的更新问题，因为每次引用的改变都必须去判断是否需要更新卡表，而这个如果是解释器去执行，那么中间可能有很多机会可以去更新卡表。但是jvm中有许多是编译的代码，是机器指令流的方式，那么也就必须将更新的这个操作一起集合在赋值的时候，这就是写屏障，写屏障类似于环绕型AOP切片，可以在赋值的后面插入更新卡表的命令。但是这里也有一个伪共享的问题，那就是因为cpu的缓存是缓存行，假设一行是64个字节，而卡表一般最简单就是字节数组，那么也就是一个缓存行里面可以放入64个卡页，也就是对应32KB的空间，如果多个线程同时对这32KB中的对象进行修改，那么由于缓存行的问题，就可能造成修改无效或者失败或者性能问题。解决方法就是在修改前加一个判断，判断这个卡页是否已经变脏，如果没有变脏，才将他变脏。控制参数为：-XX:+UseCondCardMark 为了解决局部回收时跨代引用的问题，引入了记忆集的抽象数据结构，他一般有三种精度，字长精度，对象精度，和卡精度。最常用的就是卡精度，因为没有必要花费这么多的时间和空间去记忆的这么精准。HotSpot虚拟机中每卡页为512个字节，当这个卡页中有对象存在跨代引用，则将这个卡页标志为1 写屏障 卡表的更新问题，因为每次引用的改变都必须去判断是否需要更新卡表，而这个如果是解释器去执行，那么中间可能有很多机会可以去更新卡表。但是jvm中有许多是编译的代码，是机器指令流的方式，那么也就必须将更新的这个操作一起集合在赋值的时候，这就是写屏障，写屏障类似于环绕型AOP切片，可以在赋值的后面插入更新卡表的命令。但是这里也有一个伪共享的问题，那就是因为cpu的缓存是缓存行，假设一行是64个字节，而卡表一般最简单就是字节数组，那么也就是一个缓存行里面可以放入64个卡页，也就是对应32KB的空间，如果多个线程同时对这32KB中的对象进行修改，那么由于缓存行的问题，就可能造成修改无效或者失败或者性能问题。解决方法就是在修改前加一个判断，判断这个卡页是否已经变脏，如果没有变脏，才将他变脏。控制参数为：-XX:+UseCondCardMark 并发的可达性分析 目的：当gcroot扫描线程和用户线程并发执行时，不会由于用户线程对引用的更改导致将原本是存活的对象误删除 三色标记 黑色: 存活，不会再扫描 灰色： 扫描过，但是至少还有一个引用没有扫描 白色： 还没有被扫描到的 导致黑色对象变成白色必须满足的两个条件 黑色对象新增了一条或者多条对白色对象的引用 所有的灰色对象删除对该白色对象的直接或者间接引用。 处理方法 增量更新 在黑色对象增加对白色对象的引用时，将其记录起来，等到扫描完后再单独对记录的这个黑色节点再次扫描，破坏的是第一个条件，CMS在用 原始快照 在删除灰色节点到白色节点的引用时，就把这个要删除的引用记录下来，在并发扫描结束后，再将这些重新扫描一次。可以这样理解，无论引用关系是否删除，都按照最开始的原始快照那样再扫描一次这些记录的节点。 比较 CMS使用了增量跟新，但是G1采用的是原始快照也就是TLAB，TLAB需要采用写前屏障来跟踪并发时的指针变化情况。但是原始快照可以节省并发标记和重新标记阶段的消耗。 ","date":"0001-01-01","objectID":"/jvm/:3:2","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"经典垃圾回收器 Serial （新生代收集器） 单线程 垃圾回收只有一个线程 垃圾回收中暂停所有其他线程。 新生代 复制算法 老年代 标记-整理算法 使用场景 资源受限的环境，因为他的额外内存消耗最小 ParNew 除了可以多线程并行收集之外，其他的一切都和Serial一样，照样要暂停所有其他线程，回收策略等等都一样。新生代收集器 但是在服务器端它用的相对很多，主要是它可以与CMS配合使用。在JDK9及以后，只能和CMS配合使用。也就是选择CMS之后的新生代收集就默认使用的它。 Parallel Scavenge（新生代收集器） 多线程并行收集，标记复制算法 目标 达到一个可控制的吞吐量，而CMS等关注的是尽量缩短垃圾收集时用户线程的停顿时间 吞吐量 = 运行用户代码时间 / 运行用户代码时间 + 运行垃圾收集时间 控制参数 -XX:MaxGCPauseMilis 控制最大垃圾收集停顿时间 毫秒数，但是设置的越低，是去缩减新生代的大小来达到的，增加了收集次数，但是减少了时间 -XX:GCTimeRatio 设置吞吐量 可以设置一个0-100内的整数，比如19，那么系统则保证垃圾回收时间小于1/(1 + 19) 等于5%以内。默认是99，也就是保证小于1%； -XX:+UseAdativeSizePolicy jvm根据系统状态去调节时间和吞吐量参数，但是你可以给他一个目标，比如你设置最大停顿时间为100ms，它则会往这个方向去优化 Serial Old （老年代回收） 单线程，标记整理 使用场景： jdk5之前配合Parallel Scavenge 使用 CMS收集器失败之后的后备预案 Parallel Old（老年代回收） 是Parallel Scavenge的老年代版本 多线程并发收集，标记-整理算法，JDK6开始提供 使用场景： 配合Parallel Scavenge使用，在一些注重吞吐量的系统中使用 CMS (Concurrent Mark Sweep)收集器（老年代回收） 目标 获取最短停顿时间 标记清除算法 运行过程 初始标记 标记那些GC roots直接引用的对象，JDK7及以前是单线程，jdk8以后改为多线程 并发标记 从初始标记的开始扫描所有的对象图 重新标记 增量更新，主要为了避免删除那些存活的但是被标记为白色的对象。 并发清理 缺点 对处理器资源非常敏感，不适合在一些处理器内核数量较小的平台上使用。 CMS无法处理浮动垃圾。因为并发时用户线程在执行，肯定会产生很多垃圾，但是这些垃圾不在原本的对象图中，所有无法被收集。这样导致CMS必须留出空间给并发收集时新对象的分配空间用。如果新对象分配时申请不到空间，则将导致CMS并发收集失败，导致需要掉用备用的Serial Old来进行垃圾回收，但是这样就要暂停掉所有用户线程。 由于CMS采用的是标记清除算法，所以肯定会导致很多的垃圾碎片，这样就肯定会导致FULL GC提前触发。 G1(Garbage First)全功能垃圾回收器 它并不将堆按照原本的新生代，老年代这样的来划分内存结构，而是将整个堆划分为一个个的region，每个region都可以按照需求变为新生代或者老年代。 有一类特殊的region，humongous，专门用来存放大对象，避免复制，直接进入老年代，大对象的判断是是否大于region的1/2， SATB 原始快照，采用原始快照来解决并发标记时可能将存活的对象清理。 Rset 记忆集，和卡表有点像，但是不一致，卡表采用的是points-out（我引用了谁），G1的记忆集用的是points-in(谁引用了我的对象)。 停顿预测模型 通过前面的垃圾回收的时间收集，以衰减均值作为理论模型，也就是新数据所占权重比旧数据高。 执行过程 初始标记 暂停用户进程 并发标记 最终标记 重新标记TLAB剩余的引用 清除垃圾 把决定回收的region里面所有存活的对向复制到另一个空region中去，然后清除掉这个旧region的全部内容 shenandoah G1的升级版，最重要的是支持了并发的整理算法，以及低延迟，他们的项目目标是做到10ms一下 去掉了G1中非常占用资源的Rset，改为连接矩阵来进行标记跨区引用 过程 初始标记 stop the world 并发标记 最终标记 并发清理 清理那些一个存活对象都没有的region 并发回收 将存活的对象复制一份到其他region，是和G1的核心差别，主要技术有读屏障和Brooks Pointers转发指针 初始引用更新 主要是等待前一步的所有并发线程都工作完毕 并发引用更新 真正的进行引用更新操作。按照地址空间的顺序来进行 最终引用更新 修正存在于GC roots中的引用。需要暂停所有用户进程 并发清理 清理掉回收集中的所有region 对象移动和用户程序的并发 保护陷进 效率低，频繁的状态转换 brooks Pointers brooks pointers 是通过在原本的对象结构的基础上，在他的前面添加一个新的引用，当这个对象不在并发移动时，值为它自己。但是在并发移动时，值为它的新的地址。 这样带来一个性能消耗，就是每次访问对象都需要访问两次。但是相比于保护陷阱带来的状态切换，还是可以接受。 但是这样带来了一个多线程访问时的问题，当jvm在移动对象时，如果这个时候有一个写入进程来修改此对象，但是假如此时jvm并没有来的及修改转发指针的地址，导致他将新的修改修改在了旧的对象上，这是绝对不允许发生的，jvm采用了cas来保证并发时对象的访问正确性的。 读写屏障 基于引用的访问屏障 ZGC收集器 基于Region，不设分代，使用了读屏障，染色指针，和内存多重映射等来实现可并发的标记-整理算法的，以低延迟为目标的 染色指针 多重映射 ","date":"0001-01-01","objectID":"/jvm/:3:3","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"垃圾回收算法 ","date":"0001-01-01","objectID":"/jvm/:4:0","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"标记清除算法 ","date":"0001-01-01","objectID":"/jvm/:4:1","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"标记整理算法 ","date":"0001-01-01","objectID":"/jvm/:4:2","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"内存分配和回收 ","date":"0001-01-01","objectID":"/jvm/:5:0","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"1. 对象优先在Eden分配 ","date":"0001-01-01","objectID":"/jvm/:5:1","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"2. 大对象直接进入老年代 ","date":"0001-01-01","objectID":"/jvm/:5:2","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"3. 长期存活（年龄大于等于15）则进入老年代 ","date":"0001-01-01","objectID":"/jvm/:5:3","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"4. 动态对象年龄判断（只要Suivivor中同年龄的对象超过Survivor空间的一半，则大于等于此年龄的全部进入老年代） ","date":"0001-01-01","objectID":"/jvm/:5:4","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"5. 空间分配担保 在发送Minor gc前需要判断老年代是否有连续的大于新生代所有对象的总空间或者历次进入到老年代的平均大小，如果有，则进行一次Minor gc，如果最后发现老年代空间不够，则触发一次Full gc。 ","date":"0001-01-01","objectID":"/jvm/:5:5","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"OOM异常分析和排除 ","date":"0001-01-01","objectID":"/jvm/:6:0","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"堆OOM -Xms -Xmx -XX:+HeapDumpOnOutOfMemoryError 出现异常时Dump出内存堆转储快照 ","date":"0001-01-01","objectID":"/jvm/:6:1","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"面试问题 ","date":"0001-01-01","objectID":"/jvm/:7:0","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"new 一个对象的过程 先去常量池，查找这个类的符号引号，判断这个类是否被加载进jvm。 如果类已经加载进jvm，则继续下一步操作，如果没有，加载进jvm 因为新建对象的类信息已经加载进jvm，所以此类的对象所需要占有的大小是确定的，在堆中分配一块此大小的地址给此对象。 因为不同垃圾回收器可能不一定有空间压缩操作，所以分配地址就有可能有两种情况，第一种是简单的移动一下指针，因为此时的空间是被压缩过的。另一种就是比较复杂的空闲链表，在其中找到一块比这个大的切割后分配给他，将剩余的继续加入空闲链表。 因为new 对象在jvm中是非常常见的事，所以指针移动需要进行线程安全保证。虚拟机一般上是使用CAS配上失败重试来保证更新操作的原子性。另外一种保证线程安全的就是通过TLAB（本地线程分配缓冲），当jvm中创建一个线程时，就在堆中提前给他分配一块地址，此线程就在此空间内进行对象内存分配。只有此空间用完了，重新分配时才需要保证线程安全。 空间分配后，应该将该空间里面进行全部的初始化（不包括对象头），以保证类属性可以被初始化，当然这一步操作可以在TLAB分配时就顺便进行。 jvm对对象头进行一定的设置，比如这个对象的是什么类的实例，如果才能找到元数据，对象的gc分类等等。 上面步骤完成后，类的创建就基本上完成了，但是还有一步很重要的操作没有进行，那就是构造函数还没有执行。一般new出来的对象在new指令后面都有一个invokespecial指令，这个指令指向对象的构造方法。 ","date":"0001-01-01","objectID":"/jvm/:7:1","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"String str1 = new StringBuilder(“计算机”).append(“软件”).toString(); String str2 = new StringBuilder(\"ja\").append(\"va\").toString(); System.out.println(str1.intern() == str1); System.out.println(str2.intern() == str2); true,false从jdk7开始字符串常量池移动到了堆中，因为这些StringBuilder创建对象也在堆中，所以这个时候就进行了更改，Intern方法时，直接就将堆中的这个对象的地址记录了下来，也就是常量池中指向的就是这个地址。 ","date":"0001-01-01","objectID":"/jvm/:7:2","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"- : 标准VM选项，VM规范的选项 -X: 非标准VM选项，不保证所有VM支持 -XX: 高级选项，高级特性，但属于不稳定的选项 ","date":"0001-01-01","objectID":"/jvm/:8:0","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"虚拟机的类加载机制 ","date":"0001-01-01","objectID":"/jvm/:9:0","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"加载过程 加载 通过类的全限定名拿到类的二进制字节流，并且将二进制字节流转化为方法区的运行时数据结构，并且在堆中生成一个此类的Class对象 连接 验证 文件格式验证 元数据验证 语义分析代码，符合java的规范 字节码验证 符号引用验证 准备 为类属性分配内存并且初始化为00000.final修饰的常量此时会被赋值。 解析 把符号引用转化为直接引用 初始化 执行clinit方法，类变量的赋值语句和静态语句块中的语句，多线程时必须保证只有一个线程去执行这个操作。 ","date":"0001-01-01","objectID":"/jvm/:9:1","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"类加载器 启动类加载器 lib目录 扩展类加载器 lib/ext 应用程序加载器 加载类路径下 双亲委派模型 类加载类之前先询问父类是否可以加载，如果可以，由父类加载。这样避免核心的Java基础类被自定义类加载器载入。保证java的基本稳定性。 双亲委派模型的三次破坏 findClass方法，因为JDK1.2提出双亲委派的时候，有很多自定义的类加载器在使用，自定义类加载器的时候不要重写loadClass方法，而是去重写findClass方法。 例如JNDI这些服务，他们的基础上层类需要下层加载器来加载，所以引入了一个线程上下文加载器。 热部署和热替换，没有使用双亲委派，而是更为复杂的网状结构。 ","date":"0001-01-01","objectID":"/jvm/:9:2","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"虚拟机字节码执行引擎 ","date":"0001-01-01","objectID":"/jvm/:10:0","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"栈帧 局部变量表 操作数栈 动态连接 方法返回地址 正常退出 出错 ","date":"0001-01-01","objectID":"/jvm/:10:1","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"方法调用 解析 invokestatic invokespecial 被final修饰的方法（invokevirtual） 分派 静态分派 依赖静态类型来决定方法分配版本的都是，典型的就是方法重载。静态类型指的是外观类型。 动态分派 invokevirtual 执行流程 找到操作数栈顶的第一个元素所指向对象的实际类型，然后去匹配方法的简单名称，看是否能够匹配上，如果不能，找这个对象的父类，然后继续pipe ","date":"0001-01-01","objectID":"/jvm/:10:2","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"对象 ","date":"0001-01-01","objectID":"/jvm/:11:0","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"对象的空间分布 对象头 实例信息 父类属性在前面 对齐填充 ","date":"0001-01-01","objectID":"/jvm/:11:1","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"访问方式 直接指针 因为Java中普遍还是访问对象比访问元类型要多，所以平均下来还是直接指针更快 句柄访问 ","date":"0001-01-01","objectID":"/jvm/:11:2","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"Java内存模型和线程 ","date":"0001-01-01","objectID":"/jvm/:12:0","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"主内存和工作内存 lock/unlock read/load use/assign store/write ","date":"0001-01-01","objectID":"/jvm/:12:1","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"volatile 保证变量可见性 禁止指令重排序优化 实现原理 use前必须read assign后必须store 指令重排序问题 ","date":"0001-01-01","objectID":"/jvm/:12:2","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"原子性 前面的8个操作都是原子的 ","date":"0001-01-01","objectID":"/jvm/:12:3","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"可见性 volatile syncronized unlock某变量前必须把该变量store，write回主内存 final ","date":"0001-01-01","objectID":"/jvm/:12:4","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"有序性 volatile syncronized ","date":"0001-01-01","objectID":"/jvm/:12:5","tags":["Java","JVM"],"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"1. 正则表达式 ","date":"0001-01-01","objectID":"/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/:0:1","tags":["python","爬虫"],"title":"聚焦爬虫","uri":"/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"2. bs4解析 2.1 定位标签 soup.tagName 返回文档中第一次出现的名为tagName的标签 soup.find(‘tagName’) 和soup.tagName作用一致 属性定位: soup.find(‘tagName’,class_/id/attr=‘类’) class加下划线是因为class是一个关键字 soup.find_all(…) 找到符合标准的所有的标签 soup.select() 和css一样,中间参数为选择器 soup.select(‘.class’) 可以是类选择器,id选择器,标签选择器,返回的是一个列表 层级选择 soup.select(‘ .tang \u003e ul \u003e li \u003e a’) [0] 查找清明时节的那一个标签, \u003e 表示的是层级关系(一个层级), 如果表示中间间隔多个层级,可以用空格,例如: soup.select(‘.tang \u003e ul a’)[0] 这样表示的是class属性为tang的标签下面的子标签ul下面的所有a标签(可以间隔多级,只要被ul包裹就行)的第一个a标签,也就是清明时节… 2.2 获取信息: 2.2.1 获取标签之间的文本数据 soup.xxx.text / .string / .get_text() 例如: soup.select(‘ .tang \u003e ul \u003e li \u003e a’).text 返回的数据就是清明时节..... soup.select(‘ .tang \u003e ul \u003e li \u003e a’).string soup.select(‘ .tang \u003e ul \u003e li \u003e a’).get_text() 差别: text / get_text()可以获得标签之间的所有文本内容,即时这个这个内容不是它所直属的.例如: \u003cdiv\u003e \u003ca\u003e我是a标签的直系内容\u003c/a\u003e 我是div直系的文本内容 \u003c/div\u003e 此方法可以获取所有子标签(这里是a标签)中的文本内容以及他的直系内容 string 只能获取该标签下的直系文本内容,这里就是只能获取到我是div直系的文本内容 2. 获取标签的属性值: soup.a[‘href’] 也就是和获取字典内容一样的方法 拿到a标签的href属性 ","date":"0001-01-01","objectID":"/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/:0:2","tags":["python","爬虫"],"title":"聚焦爬虫","uri":"/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"3. Xpath 3.1 定位: 3.1.1 层级定位 按照标签的层级属性进行定位 from lxml import etree # 将test.html转化为一个tree对象 tree = etree.parse('./test.html') # 查找title标签 (目标上面的html图片内容) tree.xpath('/html/head/title') # / 代表根节点或者一层的意思,后一种意思和bs4里面的\u003e作用相同 # 返回的是一个已经封装好的element对象list集合 3.1.2 属性定位 按照标签的某些属性(class,id 等等进行定位) from lxml import etree # 将test.html转化为一个tree对象 tree = etree.parse('./test.html') # 查找苏轼所在的p标签 tree.xpath('//div[@class=\"song\"]') # // 代表多层, 如果是直接//div,表示查找任意位置的div标签 # 返回的是一个已经封装好的element对象list集合 3.1.3 索引定位 按照层级和属性进行定位后,想查找这个标签下面固定位数的标签 from lxml import etree # 将test.html转化为一个tree对象 tree = etree.parse('./test.html') # 查找class=\"song\"的div tree.xpath('//div[@class=\"song\"]/p[3]') # // 代表多层, 如果是直接//div,表示查找任意位置的div标签,p[3]表示查询到的第三个p标签,注意是从1开始的 # 返回的是一个已经封装好的element对象list集合 3.2.4 相对路径解析 先解析到li,然后再由li对象开始解析, ./表示从当前对象开始 3.2.5 与 / 或 聚合多种条件 from lxml import etree # 将test.html转化为一个tree对象 tree = etree.parse('./test.html') # 查找class=\"song\"的div tree.xpath('//div[@class=\"song\"]/p[3] | //div/p') 表示无论符合前面的还是后面的,都可以 3.2 取值 3.2.1 取标签之间的值 # 取苏轼这个词 from lxml import etree # 将test.html转化为一个tree对象 tree = etree.parse('./test.html') # 查找class=\"song\"的div tree.xpath('//div[@class=\"song\"]/p[3]/text()') # // 代表多层, 如果是直接//div,表示查找任意位置的div标签,p[3]表示查询到的第三个p标签,注意是从1开始的 放回的是一个字符串列表, 注意: 1. /text()表示取p[3]的直系标签内的值,不包括其子标签的标签间的值 2. //text()表示取得这个标签下面所有的标签间的值,包括子标签的标签间 3.2.2 取标签属性值 # img标签的src属性 from lxml import etree # 将test.html转化为一个tree对象 tree = etree.parse('./test.html') # 查找class=\"song\"的div tree.xpath('//img/@src') # // 代表多层, 如果是直接//div,表示查找任意位置的div标签,p[3]表示查询到的第三个p标签,注意是从1开始的 放回的是一个字符串列表, 注意: 1. /@src表示取这个标签的这个属性值 ","date":"0001-01-01","objectID":"/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/:0:3","tags":["python","爬虫"],"title":"聚焦爬虫","uri":"/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"},{"categories":["算法","leetcode","区间dp"],"content":"363. 矩形区域不超过 K 的最大数值和 Difficulty: 困难 给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。 题目数据保证总会存在一个数值和不超过 k 的矩形区域。 示例 1： 输入：matrix = [[1,0,1],[0,-2,3]], k = 2 输出：2 解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。 示例 2： 输入：matrix = [[2,2,-1]], k = 3 输出：3 提示： m == matrix.length n == matrix[i].length 1 \u003c= m, n \u003c= 100 -100 \u003c= matrix[i][j] \u003c= 100 -10\u003csup\u003e5\u003c/sup\u003e \u003c= k \u003c= 10\u003csup\u003e5\u003c/sup\u003e **进阶：**如果行数远大于列数，该如何设计解决方案？ Solution Language: java 思路1： 利用区间db的思路去做，也就是先定义一个状态sums[i][j][rlen][clen]，表示以i，j为矩阵左顶点，rlen行，clen列的矩阵的数值和。然后就是去思考如何做一个正确的状态转换方程，在这里面需要一起思考如何去进行循环以便于计算当前状态转换时前一个状态已经被计算过了。 代码1： class Solution { public int maxSumSubmatrix(int[][] matrix, int k) { int m = matrix.length, n = matrix[0].length; int[][][][] sums = new int[2][n][n + 1][m + 1]; int res = Integer.MIN_VALUE; int flag = 0; for (int i = m - 1;i \u003e= 0;i--) { for (int j = n - 1;j \u003e= 0;j--) { for (int rlen = 1;rlen + j \u003c= n;rlen++) { for (int clen = 1;clen + i \u003c= m;clen++) { if (rlen == 1 \u0026\u0026 clen == 1) { sums[flag][j][rlen][clen] = matrix[i][j]; } else if (rlen == 1) { sums[flag][j][rlen][clen] = sums[(flag + 1) % 2][j][rlen][clen - 1] + matrix[i][j]; } else if (clen == 1) { sums[flag][j][rlen][clen] = sums[flag][j + 1][rlen - 1][clen] + matrix[i][j]; } else { sums[flag][j][rlen][clen] = sums[flag][j][1][clen] + sums[flag][j + 1][rlen - 1][clen]; } if (sums[flag][j][rlen][clen] \u003e res \u0026\u0026 sums[flag][j][rlen][clen] \u003c= k) { res = sums[flag][j][rlen][clen]; } } } } flag = (flag + 1) % 2; sums[flag] = new int[n][n + 1][m + 1]; } return res; } } 官方思路： 枚举i - k 行的矩阵不同列的前缀和，而后题目便变成了在一个一维的前缀和集合中求最接近k的区间和。区间和sum = Sr - Sl;Sr - Sl \u003c= k;此时可以利用TreeSet集合的ceiling函数求Sl，然后用Math.max比较的到最大值。 官方题解： class Solution { public int maxSumSubmatrix(int[][] matrix, int k) { int ans = Integer.MIN_VALUE; int m = matrix.length, n = matrix[0].length; for (int i = 0; i \u003c m; ++i) { // 枚举上边界 int[] sum = new int[n]; for (int j = i; j \u003c m; ++j) { // 枚举下边界 for (int c = 0; c \u003c n; ++c) { sum[c] += matrix[j][c]; // 更新每列的元素和 } TreeSet\u003cInteger\u003e sumSet = new TreeSet\u003cInteger\u003e(); sumSet.add(0); int s = 0; for (int v : sum) { s += v; Integer ceil = sumSet.ceiling(s - k); if (ceil != null) { ans = Math.max(ans, s - ceil); } sumSet.add(s); } } } return ans; } } 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/solution/ju-xing-qu-yu-bu-chao-guo-k-de-zui-da-sh-70q2/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"0001-01-01","objectID":"/%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87k%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC%E5%92%8C/:0:1","tags":["leetcode","算法","区间dp","dp"],"title":"矩形区域不超过k的最大数值和_363","uri":"/%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87k%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC%E5%92%8C/"},{"categories":["算法","排序算法"],"content":"[TOC] ","date":"0001-01-01","objectID":"/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/:0:0","tags":["排序","算法"],"title":"排序算法总结","uri":"/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"},{"categories":["算法","排序算法"],"content":"排序算法 快速排序 思路： 先寻找一个坐标，然后将小于坐标的都放到坐标的左边，大于等于坐标的都放到坐标的右边，如此将原数组分成左右两块数组，对每个子数组执行上述的操作，直到子数组长度为1或者为空。（递归） 代码： public static void quick_sort(int[] nums,int start,int end) { // 递归终止条件 if (start \u003e= end) { return; } int point = nums[start]; int l = start - 1,r = end + 1; while (l \u003c r) { do l++; while (l \u003c r \u0026\u0026 nums[l] \u003c point); do r--; while (r \u003e l \u0026\u0026 nums[r] \u003e= point); // 因为当l++ 到等于r后，后续r--会至少执行一次，导致r \u003c l,但是此时不应该发生交换 if (l \u003c r){ int temp = nums[l]; nums[l] = nums[r]; nums[r] = temp; } } quick_sort(nums,start,r); quick_sort(nums,r+1,end); } 时间复杂度： 最坏时间复杂度： O(n^2) 平均时间复杂度：O(n·logn) 最优时间复杂度：O(n·logn) 冒泡排序 思路： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 算法： private int[] bubbleSort(int[] array) { int temp; for (int i = 0; i \u003c array.length - 1; i++) { boolean Flag = false; // 是否发生交换。没有交换，提前跳出外层循环 for (int j = 0; j \u003c array.length - 1 - i; j++) { if (array[j] \u003e array[j + 1]) { temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; Flag = true; } } if (!Flag) { break; } } return array; } 时间复杂度： 最坏时间复杂度： O(n^2) 平均时间复杂度：O(n^2) 最优时间复杂度：O(n) 插入排序 思路： 在数组前部维护一个有序区间，初始时有序区间的长度为1，而后从index = 1开始逐个添加进入有序区间，就和抓牌时抓一个插入一个一样。因为少了很多比较次数，但是相比之下，他每次往有序数组中插入时都需要移动一部分元素 算法： /** * 插入排序 * @param nums */ public static void insertionSort(int[] nums) { int len = nums.length; for (int i = 1; i \u003c len; i++) { int temp = nums[i]; int pointer = i; for (int j = i - 1; j \u003e= 0; j--) { if (nums[j] \u003e= temp) { nums[j + 1] = nums[j]; pointer = j; } } nums[pointer] = temp; } } 时间复杂度： 最坏时间复杂度： O(n^2) 平均时间复杂度：O(n^2) 最优时间复杂度：O(n) 选择排序 思路： 选择，顾名思义，每次选择待排序数组中的剩余的最大值（最小值）移动到有序序列的最前（最后）。思考一下，我们需要在代码中维护两个循环变量，一个是下一个极值放置位置的索引，另一个就是循环查找极值的循环。 算法： /** * 选择排序 * @param nums */ public static void maopao_sort(int[] nums) { int n = nums.length; for (int i = n - 1; i \u003e= 0; i--) { int nextIndex = 0; for (int j = 0; j \u003c= i;j++) { if (nums[j] \u003e nums[nextIndex]) { nextIndex = j; } } int temp = nums[i]; nums[i] = nums[nextIndex]; nums[nextIndex] = temp; } } 时间复杂度： 最坏时间复杂度： O(n^2) 平均时间复杂度：O(n^2) 最优时间复杂度：O(n^2) 堆排序 思路： 指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点 整体上有两个步骤，第一个就是构建堆，将数组构建为一个大顶堆或者小顶堆 第二步，在数组尾部(前部)维护一个有序序列，每次将堆顶元素移到有序序列的最前面，而后将原本在此地的值移入堆顶，然后重新构建堆 算法： /** * 堆排序 * @Classname HeapSort * @Description TODO * @Date 2021/4/22 21:21 * @Created by Huan */ public class HeapSort { /** * 堆排序的主要入口方法，共两步。 */ public static void sort(int[] arr) { /* * 第一步：将数组堆化 * beginIndex = 第一个非叶子节点。 * 从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。 * 叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。 */ int len = arr.length - 1; int beginIndex = (arr.length \u003e\u003e 1)- 1; for (int i = beginIndex; i \u003e= 0; i--) { maxHeapify(arr,i, len); } /* * 第二步：对堆化数据排序 * 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。 * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。 * 直至未排序的堆长度为 0。 */ for (int i = len; i \u003e 0; i--) { swap(arr,0, i); maxHeapify(arr,0, i - 1); } } private static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } /** * 调整索引为 index 处的数据，使其符合堆的特性。 * * @param index 需要堆化处理的数据的索引 * @param len 未排序的堆（数组）的长度 */ private static void maxHeapify(int[] arr,int index, int len) { int li = (index \u003c\u003c 1) + 1; // 左子节点索引 int ri = li + 1; // 右子节点索引 int cMax = li; // 子节点值最大索引，默认左子节点。 if (li \u003e len) return; // 左子节点索引超出计算范围，直接返回。 if (ri \u003c= len \u0026\u0026 arr[ri] \u003e arr[li]) // 先判断左右子节点，哪个较大。 cMax = ri; if (arr[cMax] \u003e arr[index]) { swap(arr,cMax, index); // 如果父节点被子节点调换， maxHeapify(arr,cMax, len); // 则需要继续判断换下后的父节点是否符合堆的特性。 } } /** * 测试用例 * * 输出： * [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9] */ public static void main(String[] args) { int[] arr = new int[] {3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6}; sort(arr); System.out.println(Arrays.toString(arr)); } } 时间复杂度： 最坏时间复杂度： O(n·logn) 平均时间复杂度：O(n·logn) 最优时间复杂度：O(n·logn) 希尔排序 思路： 在插入排序中，如果某个数开始所处位置和他排序后所处位置相差过大，则会导致非常多的交换操作，而希尔排序则是利用这一点，在开始的时候使用大步长，尽量的使nums[i]的位置尽早的在排序后所处位置附近。理论证明插入排序中占主要时间的是交换操作。 由希尔排序的含义可知， 算法： p","date":"0001-01-01","objectID":"/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/:0:1","tags":["排序","算法"],"title":"排序算法总结","uri":"/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"}]
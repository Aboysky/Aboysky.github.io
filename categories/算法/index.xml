<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>算法 on Aboysky</title><link>https://aboysky.com/categories/%E7%AE%97%E6%B3%95/</link><description>Recent content in 算法 on Aboysky</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>aboyskyi@gmail.com (Aboysky)</managingEditor><webMaster>aboyskyi@gmail.com (Aboysky)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 09 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://aboysky.com/categories/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>矩形区域不超过k的最大数值和_363</title><link>https://aboysky.com/posts/%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87k%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC%E5%92%8C/</link><pubDate>Sat, 09 Oct 2021 00:00:00 +0000</pubDate><author>aboyskyi@gmail.com (Aboysky)</author><guid>https://aboysky.com/posts/%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87k%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC%E5%92%8C/</guid><description>363. 矩形区域不超过 K 的最大数值和 Difficulty: 困难 给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。 题目数据保证总会存</description></item><item><title>下一个排列</title><link>https://aboysky.com/posts/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</link><pubDate>Wed, 25 Aug 2021 20:58:44 +0000</pubDate><author>aboyskyi@gmail.com (Aboysky)</author><guid>https://aboysky.com/posts/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</guid><description>31. 下一个排列 Difficulty: 中等 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重</description></item><item><title>在D天送达包裹的能力</title><link>https://aboysky.com/posts/%E5%9C%A8d%E5%A4%A9%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/</link><pubDate>Mon, 26 Apr 2021 15:07:22 +0000</pubDate><author>aboyskyi@gmail.com (Aboysky)</author><guid>https://aboysky.com/posts/%E5%9C%A8d%E5%A4%A9%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/</guid><description>1011. 在 D 天内送达包裹的能力 Difficulty: 中等 传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。 传送带上的第 i 个包裹的重量为 weights[i]。每一天</description></item><item><title>最长有效括号</title><link>https://aboysky.com/posts/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</link><pubDate>Mon, 26 Apr 2021 09:27:43 +0000</pubDate><author>aboyskyi@gmail.com (Aboysky)</author><guid>https://aboysky.com/posts/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</guid><description>32. 最长有效括号 Difficulty: ** 示例 1： 输入：s = &amp;ldquo;(()&amp;rdquo; 输出：2 解释：最长有效括号子串是 &amp;ldquo;()&amp;rdquo; 示例 2： 输入：s = &amp;ldquo;)()())&amp;rdquo; 输出：4 解释：最长有效括号子串是 &amp;ldquo;()()&amp;rdquo; 示例 3： 输入：</description></item><item><title>合并K个有序链表</title><link>https://aboysky.com/posts/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link><pubDate>Sun, 25 Apr 2021 18:40:45 +0000</pubDate><author>aboyskyi@gmail.com (Aboysky)</author><guid>https://aboysky.com/posts/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid><description>23. 合并K个升序链表 Difficulty: 困难 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 1 2 3 4 5</description></item><item><title>组合总和归纳</title><link>https://aboysky.com/posts/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E5%BD%92%E7%BA%B3/</link><pubDate>Sat, 24 Apr 2021 13:22:46 +0000</pubDate><author>aboyskyi@gmail.com (Aboysky)</author><guid>https://aboysky.com/posts/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E5%BD%92%E7%BA%B3/</guid><description/></item><item><title>动态规划</title><link>https://aboysky.com/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link><pubDate>Sun, 18 Apr 2021 09:55:12 +0000</pubDate><author>aboyskyi@gmail.com (Aboysky)</author><guid>https://aboysky.com/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid><description>动态规划 5. 最长回文子串 Difficulty: 中等 给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 1 2 3 输入：s = &amp;#34;babad&amp;#34; 输出：&amp;#34;bab&amp;#34; 解释：&amp;#3</description></item><item><title>排序算法总结</title><link>https://aboysky.com/posts/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</link><pubDate>Wed, 31 Mar 2021 16:53:43 +0000</pubDate><author>aboyskyi@gmail.com (Aboysky)</author><guid>https://aboysky.com/posts/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</guid><description>[TOC] 排序算法 快速排序 思路： 先寻找一个坐标，然后将小于坐标的都放到坐标的左边，大于等于坐标的都放到坐标的右边，如此将原数组分成左右两块数组，对每</description></item></channel></rss>
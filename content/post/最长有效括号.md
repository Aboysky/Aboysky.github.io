---
title: 最长有效括号
tags:
  - leetcode
  - Stack
categories:
  - 算法
  - leetcode
  - 栈
date: 2021-04-26 09:27:43
---


### [32\. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

Difficulty: ** 示例 1： 输入：s = "(()" 输出：2 解释：最长有效括号子串是 "()" 示例 2： 输入：s = ")()())" 输出：4 解释：最长有效括号子串是 "()()" 示例 3： 输入：s = "" 输出：0   提示： 0 <= s.length <= 3 * 104 s[i] 为 '(' 或 ')' **


给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。


**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```
输入：s = ""
输出：0
```

**提示：**

*   `0 <= s.length <= 3 * 10<sup>4</sup>`
*   `s[i]` 为 `'('` 或 `')'`


#### Solution

Language: **Java**

##### 代码一：

```Java
/**
 * 采用栈加上标记
 */
class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        if (s == null || s.length() == 0) {
            return 0;
        }
        int[] sums = new int[s.length()];
        int res = 0,temp = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                st.push(i);
            } else {
                if (!st.isEmpty()) {
                    sums[st.peek()] = 1;
                    sums[i] = 1;
                    st.pop();
                }
            }
        }
        for (int i = 0;i < sums.length;i++) {
            if (sums[i] == 1) {
                temp += 1;
            } else {
                temp = 0;
            }
            res = Math.max(res,temp);
        }
        
        return res;
    }
}
```

##### 代码二：

``` java
public class Solution {
    public int longestValidParentheses(String s) {
        int maxans = 0;
        Deque<Integer> stack = new LinkedList<Integer>();
        stack.push(-1);
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                stack.push(i);
            } else {
                stack.pop();
                if (stack.empty()) {
                    stack.push(i);
                } else {
                    maxans = Math.max(maxans, i - stack.peek());
                }
            }
        }
        return maxans;
    }
}
```

##### 代码三：

```java
/**
 * dp 我想不完整dp迭代式
 */
public class Solution {
    public int longestValidParentheses(String s) {
        int maxans = 0;
        int[] dp = new int[s.length()];
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == ')') {
                if (s.charAt(i - 1) == '(') {
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxans = Math.max(maxans, dp[i]);
            }
        }
        return maxans;
    }
}

```

